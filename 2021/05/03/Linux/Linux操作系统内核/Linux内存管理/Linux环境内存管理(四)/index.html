<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux环境内存管理(四) | Barret Blog</title><meta name="keywords" content="IT"><meta name="author" content="Barret"><meta name="copyright" content="Barret"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="内存碎片​    内存管理问题：**内存碎片太小和管理内存碎片的效率**问题。内存碎片问题产生的原因是内存分配较小，并且分配的这些小的内存生存周期又比较长，反复申请后将产生内存碎片。  优点：提高分配速度，便于内存管理，防止内存泄露； 缺点：大量的内存碎片会使系统缓慢，内存使用率低，浪费大；  ​    如何避免内存碎片？   少用动态内存分配的函数(尽量使用栈空间)； 分配内存和释放的内存尽量在">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux环境内存管理(四)">
<meta property="og:url" content="http://example.com/2021/05/03/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E5%9B%9B)/index.html">
<meta property="og:site_name" content="Barret Blog">
<meta property="og:description" content="内存碎片​    内存管理问题：**内存碎片太小和管理内存碎片的效率**问题。内存碎片问题产生的原因是内存分配较小，并且分配的这些小的内存生存周期又比较长，反复申请后将产生内存碎片。  优点：提高分配速度，便于内存管理，防止内存泄露； 缺点：大量的内存碎片会使系统缓慢，内存使用率低，浪费大；  ​    如何避免内存碎片？   少用动态内存分配的函数(尽量使用栈空间)； 分配内存和释放的内存尽量在">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650272949&t=18f99d2e597ef4e5080a0e7cdc68b6e1">
<meta property="article:published_time" content="2021-05-03T07:04:16.000Z">
<meta property="article:modified_time" content="2022-03-22T01:24:40.489Z">
<meta property="article:author" content="Barret">
<meta property="article:tag" content="IT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650272949&t=18f99d2e597ef4e5080a0e7cdc68b6e1"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/05/03/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E5%9B%9B)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux环境内存管理(四)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-22 09:24:40'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F14206928472%2F1000.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650157497&amp;t=70dfbdc4919a4e744f090628aaf5059d" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Barret Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux环境内存管理(四)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-03T07:04:16.000Z" title="发表于 2021-05-03 15:04:16">2021-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-22T01:24:40.489Z" title="更新于 2022-03-22 09:24:40">2022-03-22</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux环境内存管理(四)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="内存碎片"><a href="#内存碎片" class="headerlink" title="内存碎片"></a>内存碎片</h1><p>​    内存管理问题：**<u>内存碎片太小</u><strong>和</strong><u>管理内存碎片的效率</u>**问题。内存碎片问题产生的原因是内存分配较小，并且分配的这些小的内存生存周期又比较长，反复申请后将产生内存碎片。</p>
<blockquote>
<p>优点：提高分配速度，便于内存管理，防止内存泄露；</p>
<p>缺点：大量的内存碎片会使系统缓慢，内存使用率低，浪费大；</p>
</blockquote>
<p>​    如何避免内存碎片？</p>
<blockquote>
<ol>
<li>少用动态内存分配的函数(尽量使用栈空间)；</li>
<li>分配内存和释放的内存尽量在同一个函数中；</li>
<li>尽可能申请大块的2的指数幂大小的内存空间；</li>
<li>外部碎片避免 —— 伙伴系统算法；</li>
<li>内部碎片避免 —— slab算法；</li>
<li>自己进行内存管理工作，设计内存池；</li>
</ol>
</blockquote>
<hr>
<h1 id="伙伴-Buddy-算法"><a href="#伙伴-Buddy-算法" class="headerlink" title="伙伴(Buddy)算法"></a>伙伴(Buddy)算法</h1><p>​    伙伴算法是计算机算法的一种，目的是为了核心内存管理能够快速响应请求，尽可能地在提高内存利用率的同时<strong>减少内存碎片</strong>的一种算法。伙伴关系定义为：由一个母体分成两个各方面属性都一致的两个子实体，这两个子实体处于伙伴关系。操作系统在分配内存时将一块内存分成两个大小相等的内存块，这两个内存块就处于伙伴关系。</p>
<p>采用一个二进制数来表示伙伴关系，位为1表示一个块在使用，为0表示两个页面块都空闲或者都在使用。这个就是后面所说的位图。</p>
<blockquote>
<p>系统根据该位为0或位为1来决定是否使用或者分配该页面块，系统每次分配和回收伙伴块时都要对它们的伙伴位跟1进行<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%BC%82%E6%88%96%E8%BF%90%E7%AE%97">异或运算</a>。所谓<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%BC%82%E6%88%96">异或</a>是指刚开始时，两个伙伴块都空闲，它们的伙伴位为0，如果其中一块被使用，<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E5%BC%82%E6%88%96">异或</a>后得1。</p>
</blockquote>
<p>伙伴关系需要满足的条件：</p>
<blockquote>
<p>满足三个条件：两个块大小相等，物理地址连续，从同一个大块拆分出来。</p>
</blockquote>
<p>​    伙伴算法实际上就是为了<strong>避免外部碎片</strong>问题所采用的算法。该算法为了内核提供了一个用于分配连续的页而建立的一种高效的分配策略。</p>
<blockquote>
<p>外部碎片：指的是还没有被分配出去(不属于任何进程)，但是由于太小了无法分配给申请内存空间的新进程的内存空闲区域</p>
</blockquote>
<h2 id="伙伴算法原理"><a href="#伙伴算法原理" class="headerlink" title="伙伴算法原理"></a>伙伴算法原理</h2><p>​    在内核中使用struct page结构体来描述每一个物理页(4K)，也叫作页框。但是在实际应用中可能会申请连续的物理页且数目无法确定。为了便于页面的维护，就将多个页面组成内存块，每个内存块都有2的方幂个页。</p>
<p>​    Linux把所有的空闲页框分组为11个块链表，每个链表上的页框块都是固定的，在<strong>第i条链表中每个页框块都包含2的i次方个连续页</strong>。每个块链表</p>
<p><img src="https://cdn.jsdelivr.net/gh/anyeyueren/picgoimg/studyImg/%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95%E7%BB%84%E7%BB%87%E7%BB%93%E6%9E%84.jpg"></p>
<p>举例说明工作原理：</p>
<blockquote>
<p>情景：假设要求分配一个块大小为128个页面(由多个页面组成的块叫页面块)，伙伴算法如何处理？</p>
<p>原理：</p>
<p>(1)  该算法先在块大小为128个页面的链表中查找，看是否有这样的空闲块，如果有就直接分配；</p>
<p>(2)  如果没有就查找下一个更大的块，就是在块大小为256个页面的链表中查找一个空闲块，如果存在就将这个256个页面分成2等份，一份分配出去，另一份插入到块大小为128个页面的链表中；</p>
<p>(3) 如果256个页面的链表中没有空闲块，就继续找更大的块，即512个页面的块。如果存在这样的块，内核从512个页面中分出128个页面满足要求，接着从384个剩下的页面中取出256个页面插入到256页面链表中，最后将剩下的128个页面插入到128页面链表中；</p>
<p>(4) 如果不存在就继续往更大的找，知道查到最大的块链表也没有空闲块的话就放弃分配，发出错信息；</p>
</blockquote>
<h2 id="申请和回收"><a href="#申请和回收" class="headerlink" title="申请和回收"></a>申请和回收</h2><p>​    伙伴算法的申请流程：</p>
<blockquote>
<ol>
<li>申请 2^i 个页块存储空间，如果 2^i 对应的块链表有空闲页块，则分配给应用；</li>
<li>如果没有空闲页块，则查找 2^(i 1) 对应的块链表是否有空闲页块，如果有，则分配 2^i 块链表节点给应用，另外 2^i 块链表节点插入到 2^i 对应的块链表中；</li>
<li>如果 2^(i 1) 块链表中没有空闲页块，则重复步骤 2，直到找到有空闲页块的块链表；</li>
<li>如果仍然没有，则返回内存分配失败；</li>
</ol>
</blockquote>
<p>​    伙伴算法的回收流程是分配的逆过程，也可以看做是伙伴的合并过程：</p>
<blockquote>
<ol>
<li>当释放一个块时，先在其对应的链表中考察是否有伙伴存在，如果没有伙伴块存在就直接把要释放的块挂入链表头；</li>
<li>如果有，则从链表中摘下伙伴，合并成一个大块，然后继续考察合并后的块在更大一级链表中是否有伙伴存在，直到不能合并或者已经合并到了最大块；</li>
</ol>
</blockquote>
<p><img src="https://pic4.zhimg.com/v2-5ecef778b542165990996b60c0ac8d3b_r.jpg" alt="preview"></p>
<p>​    在这个过程中位图的某一位对应两个互为伙伴的块，为1表示其中一块已经被分配出去，为0表示两块都空闲。释放过程根据位图判断伙伴是否存在，如果对相应位的异或操作得1，则没有伙伴可以合并，如果异或操作得0，就进行合并，并且继续按这种方式合并伙伴，直到不能合并为止。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//伙伴算法源码</span></span><br><span class="line"><span class="type">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *__<span class="title">rmqueue</span>(<span class="keyword">struct</span> <span class="title">zone</span> *<span class="title">zone</span>, <span class="title">unsigned</span> <span class="title">int</span> <span class="title">order</span>,</span></span><br><span class="line"><span class="class">						<span class="title">int</span> <span class="title">migratetype</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line"></span><br><span class="line">retry_reserve:</span><br><span class="line">	page = __rmqueue_smallest(zone, order, migratetype);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!page) &amp;&amp; migratetype != MIGRATE_RESERVE) &#123;</span><br><span class="line">		page = __rmqueue_fallback(zone, order, migratetype);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Use MIGRATE_RESERVE rather than fail an allocation. goto</span></span><br><span class="line"><span class="comment">		 * is used because __rmqueue_smallest is an inline function</span></span><br><span class="line"><span class="comment">		 * and we want just one call site</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!page) &#123;</span><br><span class="line">			migratetype = MIGRATE_RESERVE;</span><br><span class="line">			<span class="keyword">goto</span> retry_reserve;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_mm_page_alloc_zone_locked(page, order, migratetype);</span><br><span class="line">	<span class="keyword">return</span> page;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>​    编写一个伙伴算法代码，实现思路：用数组实现完全二叉树来管理内存，树节点标记使用状态，在分配和释放中通过节点的状态来进行内存块的分离与合并。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 数组实现二叉树</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">buddy</span> &#123;</span></span><br><span class="line">   <span class="type">int</span> level;  <span class="comment">// 二叉树深度</span></span><br><span class="line">    uint8_tree[<span class="number">1</span>]; <span class="comment">// 记录二叉树用来存储内存块(节点)使用情况,柔性数组，不占内存</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 分配大小为s的内存</span></span><br><span class="line"><span class="type">int</span></span><br><span class="line"><span class="title function_">buddy_alloc</span><span class="params">(<span class="keyword">struct</span> buddy * self, <span class="type">int</span> s)</span> &#123;</span><br><span class="line">    <span class="comment">// 分配大小s的内存，返回分配内存偏移量地址(首地址)</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="keyword">if</span> (s == <span class="number">0</span>) &#123;</span><br><span class="line">        size = <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 获取大于s的最小2次幂</span></span><br><span class="line">        size = (<span class="type">int</span>)next_pow_of_2(s);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">1</span> &lt;&lt; self-&gt;level;</span><br><span class="line">    <span class="keyword">if</span>(size &gt; length)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> level = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (index &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">//具体分配细节...</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 释放内存并尝试合并</span></span><br><span class="line"><span class="type">void</span></span><br><span class="line"><span class="title function_">buddy_free</span><span class="params">(<span class="keyword">struct</span> buddy * self, <span class="type">int</span> offset)</span> &#123;</span><br><span class="line">    <span class="comment">// 释放偏移量offset开始的内存块</span></span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> length = <span class="number">1</span> &lt;&lt; self-&gt;level;</span><br><span class="line">    <span class="type">int</span> index;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="keyword">switch</span>(self-&gt;tree[index]) &#123;</span><br><span class="line">            <span class="keyword">case</span> NODE_USED:</span><br><span class="line">        _combine(self, index);  <span class="comment">// 尝试合并</span></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">case</span> NODE_UNUSED:</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">              <span class="comment">// ...</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="算法优缺点"><a href="#算法优缺点" class="headerlink" title="算法优缺点"></a>算法优缺点</h2><p>1）尽管伙伴内存算法在内存碎片问题上已经做的相当出色，但是该算法中，一个很小的块往往会阻碍一个大块的合并，一个系统中，对内存块的分配，大小是随机的，一片内存中仅一个小的内存块没有释放，旁边两个大的就不能合并。</p>
<p>2）算法中有一定的浪费现象，伙伴算法是按2的幂次方大小进行分配内存块，当然这样做是有原因的，即为了避免把大的内存块拆的太碎，更重要的是使分配和释放过程迅速。但是他也带来了不利的一面，如果所需内存大小不是2的幂次方，就会有部分页面浪费。有时还很严重。比如原来是1024个块，申请了16个块，再申请600个块就申请不到了，因为已经被分割了。</p>
<p>3）另外拆分和合并涉及到 较多的链表和位图操作，开销还是比较大的。</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="zone"><a href="#zone" class="headerlink" title="zone"></a>zone</h3><p>伙伴算法对应的源码中数据结构是zone，定义在inlcude&#x2F;linux&#x2F;mmzone.h文件中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Fields commonly accessed by the page allocator */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* zone watermarks, access with *_wmark_pages(zone) macros */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> watermark[NR_WMARK];</span><br><span class="line"></span><br><span class="line"> <span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  * 每个 zone 在系统启动时会计算出 3 个水位值, 分别为 WMAKR_MIN, WMARK_LOW, WMARK_HIGH 水位, 这在</span></span><br><span class="line"><span class="comment">    * 页面分配器和 kswapd 页面回收中会用到</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> percpu_drift_mark;</span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span>		lowmem_reserve[MAX_NR_ZONES];</span><br><span class="line"></span><br><span class="line"> <span class="comment">//zone 中预留的内存, 为了防止一些代码必须运行在低地址区域，所以事先保留一些低地址区域的内存</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_NUMA</span></span><br><span class="line">	<span class="type">int</span> node;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  * zone reclaim becomes active if more unmapped pages exist.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		min_unmapped_pages;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>		min_slab_pages;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">per_cpu_pageset</span> __<span class="title">percpu</span> *<span class="title">pageset</span>;</span></span><br><span class="line">      <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * page管理的数据结构对象，内部有一个page的列表(list)来管理。每个CPU维护一个page list，避免</span></span><br><span class="line"><span class="comment">     * 自旋锁的冲突。这个数组的大小和NR_CPUS(CPU的数量）有关，这个值是编译的时候确定的</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * free areas of different sizes</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="type">spinlock_t</span>		lock;</span><br><span class="line">        <span class="comment">//对zone并发访问的保护的自旋锁</span></span><br><span class="line">       <span class="type">int</span>                     all_unreclaimable; <span class="comment">/* All pages pinned */</span></span><br><span class="line">       <span class="meta">#<span class="keyword">ifdef</span> CONFIG_MEMORY_HOTPLUG</span></span><br><span class="line">       <span class="comment">/* see spanned/present_pages for more description */</span></span><br><span class="line">       <span class="type">seqlock_t</span>		span_seqlock;</span><br><span class="line">       <span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">       <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span>	<span class="title">free_area</span>[<span class="title">MAX_ORDER</span>];</span></span><br><span class="line">        <span class="comment">//页面使用状态的信息，以每个bit标识对应的page是否可以分配</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_SPARSEMEM</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">long</span>		*pageblock_flags;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> <span class="comment">/* CONFIG_SPARSEMEM */</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_COMPACTION</span></span><br><span class="line">       <span class="type">unsigned</span> <span class="type">int</span>		compact_considered;</span><br><span class="line">       <span class="type">unsigned</span> <span class="type">int</span>		compact_defer_shift;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">ZONE_PADDING(_pad1_)</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Fields commonly accessed by the page reclaim scanner */</span></span><br><span class="line"><span class="type">spinlock_t</span>		lru_lock;	</span><br><span class="line"></span><br><span class="line"> <span class="comment">//LRU(最近最少使用算法)的自旋锁</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">zone_lru</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">	&#125; lru[NR_LRU_LISTS];</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">zone_reclaim_stat</span> <span class="title">reclaim_stat</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>		pages_scanned;	   <span class="comment">/* since last reclaim */</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span>		flags;		   <span class="comment">/* zone flags, see below */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Zone statistics */</span></span><br><span class="line"><span class="type">atomic_long_t</span>		vm_stat[NR_VM_ZONE_STAT_ITEMS];</span><br><span class="line"></span><br><span class="line"><span class="comment">//zone 计数</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">  * The target ratio of ACTIVE_ANON to INACTIVE_ANON pages on</span></span><br><span class="line"><span class="comment">    * this zone&#x27;s LRU.  Maintained by the pageout code.</span></span><br><span class="line"><span class="comment">      */</span></span><br><span class="line">      <span class="type">unsigned</span> <span class="type">int</span> inactive_ratio;</span><br><span class="line"></span><br><span class="line">ZONE_PADDING(_pad2_)</span><br><span class="line"><span class="comment">/* Rarely used or read-mostly fields */</span></span><br><span class="line">   <span class="type">wait_queue_head_t</span>	* wait_table;</span><br><span class="line"></span><br><span class="line"> <span class="comment">//待一个page释放的等待队列哈希表。它会被wait_on_page()，unlock_page()函数使用. 用</span></span><br><span class="line"> <span class="comment">//哈希表，而不用一个等待队列的原因，防止进程长期等待资源</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		wait_table_hash_nr_entries;</span><br><span class="line"> <span class="comment">//哈希表中的等待队列的数量</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		wait_table_bits;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> * Discontig memory support fields.</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">pglist_data</span>	*<span class="title">zone_pgdat</span>;</span></span><br><span class="line"></span><br><span class="line"> <span class="comment">//指向这个zone所在的pglist_data对象</span></span><br><span class="line">	<span class="comment">/* zone_start_pfn == zone_start_paddr &gt;&gt; PAGE_SHIFT */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		zone_start_pfn;</span><br><span class="line"><span class="comment">//和node_start_pfn的含义一样。这个成员是用于表示zone中的开始那个page在物理内存中的位置</span></span><br><span class="line"><span class="comment">//的present_pages， spanned_pages: 和node中的类似的成员含义一样</span></span><br><span class="line">       <span class="type">unsigned</span> <span class="type">long</span>		spanned_pages;	<span class="comment">/* total size, including holes */</span></span><br><span class="line">        <span class="comment">//zone 中包含的页面数量</span></span><br><span class="line">       <span class="type">unsigned</span> <span class="type">long</span>		present_pages;	<span class="comment">/* amount of memory (excluding holes) */</span></span><br><span class="line">       <span class="comment">//zone 中实际管理的页面数量. 对一些体系结构来说, 其值和 spanned_pages 相等</span></span><br><span class="line">       <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * rarely used fields:</span></span><br><span class="line"><span class="comment">       */</span></span><br><span class="line">       <span class="type">const</span> <span class="type">char</span>		*name;</span><br><span class="line">        <span class="comment">//</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    每一个物理页框都对应着一个struct page实例，而每个内存区关联一个struct zone实例，该结构中使用free_area数组对空闲页框进行管理。free_area共有MAX_ORDER个元素，其中第order个元素记录了2^(order的空闲块)。</p>
<p>​    这些空闲块在free_list中以双向链表的形式组织起来，对于同等大小的空闲块，其类型不同，将组织在不同的free_list中，nr_free记录了该free_area中总共的空闲内存块的数量。MAX_ORDER的默认值为11，那么最大内存块的大小为2^(10) &#x3D; 1024个页框。</p>
<p>​    对于同等大小的内存块，每个内存块的起始页框用于链表的节点进行相连，这些节点对应的着struct page中的lru域。</p>
<p>​    定义migrate type，简要来说就是Linux将可移动或不可移动的内存分开分配，以便最大程度的减少碎片，提升分配大块内存的能力。基于这种思路，可见上述5种migrate type最重要的就是MIGRATE_UNMOVABLE不可移动，MIGRATE_MOVABLE可移动。另一个重要的type就是MIGRATE_RESERVE，这表示page被reserve，不接受buddy system管理。</p>
<h3 id="free-area"><a href="#free-area" class="headerlink" title="free_area"></a>free_area</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">free_list</span>[<span class="title">MIGRATE_TYPES</span>];</span></span><br><span class="line"> <span class="comment">//free_area共有MAX_ORDER个元素，其中第order个元素记录了2^order的空闲块，这些</span></span><br><span class="line"> <span class="comment">//空闲块在free_list中以双向链表的形式组织起来，对于同等大小的空闲块，其类型不同，将组织在不同的free_list中</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span>		nr_free;</span><br><span class="line"> <span class="comment">//nr_free记录了该free_area中总共的空闲内存块的数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIGRATE_UNMOVABLE     0<span class="comment">//不可移动页，这类页在内存当中有固定的位置，不能移动。内核的核心分配的内存大多属于这种类型</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIGRATE_RECLAIMABLE   1<span class="comment">//可回收页，这类页不能直接移动，但可以删除，其内容页可以从其他地方重新生成，例如，映射自文件的数据属于这种类型，针对这种页，内核有专门的页面回收处理</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIGRATE_MOVABLE       2<span class="comment">//可移动页，这类页可以随意移动，用户空间应用程序所用到的页属于该类别。它们通过页表来映射，如果他们复制到新的位置，页表项也会相应的更新，应用程序不会注意到任何改变。</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIGRATE_PCPTYPES      3<span class="comment">//用来表示每CPU页框高速缓存的数据结构中的链表的迁移类型数目 </span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIGRATE_RESERVE       3<span class="comment">//在前三种的列表中都没用可满足分配的内存块时，就可以从MIGRATE_RESERVE分配</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIGRATE_ISOLATE       4 <span class="comment">//用于跨越NUMA节点移动物理内存页，在大型系统上，它有益于将物理内存页移动到接近于是用该页最频繁地CPU</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MIGRATE_TYPES         5<span class="comment">//表示迁移类型的数目</span></span></span><br></pre></td></tr></table></figure>

<h3 id="rmqueue-smallest"><a href="#rmqueue-smallest" class="headerlink" title="rmqueue_smallest"></a>rmqueue_smallest</h3><p>rmqueue_smallest()是在指定的内存区上从所请求的分配阶对应的链表开始查找所需大小的空闲块，如果不成功则从高一阶的链表上继续查找。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span></span><br><span class="line"><span class="keyword">struct</span> page *<span class="title function_">rmqueue_smallest</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="type">unsigned</span> <span class="type">int</span> order,</span></span><br><span class="line"><span class="params">                        <span class="type">int</span> migratetype)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">int</span> current_order;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">free_area</span> * <span class="title">area</span>;</span></span><br><span class="line">    <span class="comment">//指向空闲页框</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">    <span class="comment">//指向页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Find a page of the appropriate size in the preferred list */</span></span><br><span class="line"><span class="comment">//遍历order链表，current_order 当前阶，MAX_ORDER最大阶</span></span><br><span class="line">    <span class="keyword">for</span> (current_order = order; current_order &lt; MAX_ORDER; ++current_order) &#123;</span><br><span class="line">        area = &amp;(zone-&gt;free_area[current_order]);</span><br><span class="line">        <span class="keyword">if</span> (list_empty(&amp;area-&gt;free_list[migratetype]))</span><br><span class="line">        <span class="comment">//使用list_empty()检测，migratetype类型的链表为空时获取该页框</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">         page = list_entry(area-&gt;free_list[migratetype].next,</span><br><span class="line">                             <span class="keyword">struct</span> page, lru);</span><br><span class="line">                             <span class="comment">//从当前页链表项的下一项开始，获取指向的节点的struct page结构体的首地址</span></span><br><span class="line">         list_del(&amp;page-&gt;lru);</span><br><span class="line">        <span class="comment">//从链表上删除</span></span><br><span class="line">         rmv_page_order(page);</span><br><span class="line">         <span class="comment">//设置页框描述符中的private为0，该字段中本来保存的是其所处页框块的分配阶</span></span><br><span class="line">         area-&gt;nr_free--;</span><br><span class="line">         <span class="comment">//更新当前area的nr_free数</span></span><br><span class="line">         expand(zone, page, order, current_order, area, migratetype);</span><br><span class="line">         <span class="comment">//调用expand分裂</span></span><br><span class="line">         <span class="keyword">return</span> page;</span><br><span class="line">        <span class="comment">//循环条件已经不再满足，因此返回前4个页框块首页框的描述符地址page。</span></span><br><span class="line">    &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="expand"><a href="#expand" class="headerlink" title="expand"></a>expand</h3><p>​    expand()为分裂函数，如果所得到的内存块大于所请求的内存块，则按照伙伴算法的分配原理，将大的页框块分裂成小的页框块。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> <span class="title function_">expand</span><span class="params">(<span class="keyword">struct</span> zone *zone, <span class="keyword">struct</span> page *page,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> low, <span class="type">int</span> high, <span class="keyword">struct</span> free_area *area,</span></span><br><span class="line"><span class="params">    <span class="type">int</span> migratetype)</span></span><br><span class="line">    <span class="comment">//比如当前申请大小为4的页块。low表示当前申请页块的阶2，如果阶为2的链表没有空闲块，就一</span></span><br><span class="line">    <span class="comment">//直往上找，直到找到阶为4找到空闲块，则high为4。</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> size = <span class="number">1</span> &lt;&lt; high;</span><br><span class="line">    <span class="comment">//因为只需要4个，阶为4有16个，所以多余的要往阶为2和3的链表上放</span></span><br><span class="line">    <span class="comment">//左移1位</span></span><br><span class="line">    <span class="keyword">while</span> (high &gt; low) &#123;</span><br><span class="line">        area--;</span><br><span class="line">        <span class="comment">//通过将area指针自减即可得到下级链表</span></span><br><span class="line">        high--;</span><br><span class="line">        size &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//接上面的假设，刚才size=16，现在往右移一位size=8，</span></span><br><span class="line">        VM_BUG_ON(bad_range(zone, &amp;page[size]));</span><br><span class="line">        list_add(&amp;page[size].lru, &amp;area-&gt;free_list[migratetype]);</span><br><span class="line">        <span class="comment">//list_add函数将这个8个页框添加到area为3的链表中</span></span><br><span class="line">        area-&gt;nr_free++;</span><br><span class="line">        <span class="comment">//更新area为3的nr_free数</span></span><br><span class="line">        set_page_order(&amp;page[size], high);</span><br><span class="line">        <span class="comment">//经过第一次遍历将16一份为2，第二次遍历将8个页块一份为2，第三次时循环条件已不满足，则返回前4个页框块首页框的描述符地址page。</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h2 id="页框操作函数"><a href="#页框操作函数" class="headerlink" title="页框操作函数"></a>页框操作函数</h2><h3 id="alloc-pages"><a href="#alloc-pages" class="headerlink" title="alloc_pages()"></a>alloc_pages()</h3><p>​    伙伴算法中分配的是物理页，是最原始的面向页的分配方式，可以使用alloc_pages函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//分配2^(order)个连续的物理页，并返回一个指针，指向第一个物理页的page结构体</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="keyword">struct</span> page *<span class="title function_">alloc_pages</span><span class="params">(<span class="type">gfp_t</span> gfp_mask, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> alloc_pages_current(gfp_mask, order);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//对应的释放物理页的函数是free_pages，释放从地址addr开始order个物理页</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">free_pages</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">int</span> order)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">if</span> (addr != <span class="number">0</span>) &#123;</span><br><span class="line">		VM_BUG_ON(!virt_addr_valid((<span class="type">void</span> *)addr));</span><br><span class="line">		__free_pages(virt_to_page((<span class="type">void</span> *)addr), order);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Free memory management - zoned buddy allocator.  */</span></span><br><span class="line"><span class="comment">// 其中MAX_ORDER 即最大分配到到页面个数为2^10（即4M）</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> CONFIG_FORCE_MAX_ZONEORDER</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ORDER 11</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ORDER CONFIG_FORCE_MAX_ZONEORDER</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_ORDER_NR_PAGES (1 &lt;&lt; (MAX_ORDER - 1))</span></span><br></pre></td></tr></table></figure>

<p>​    从上面得到分配到的物理页之后还不能直接使用，需要进一步得到对应page的虚拟地址，此时需要调用函数page_address。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//返回page页面所映射的虚拟地址</span></span><br><span class="line"><span class="comment">//入参是一个所分配的物理页的首地址，这里就涉及到内存地址映射的知识了</span></span><br><span class="line"><span class="type">static</span> <span class="keyword">inline</span> <span class="type">void</span> *<span class="title function_">page_address</span><span class="params">(<span class="type">const</span> <span class="keyword">struct</span> page *page)</span></span><br><span class="line"> </span><br><span class="line"><span class="comment">//低端内存的映射方式：    __va((unsigned long)(page  -  mem_map)  &lt;&lt;  12)</span></span><br><span class="line"><span class="comment">//高端内存映射方式：分配一个动态结构来管理高端内存 ==&gt; struct page_address_map</span></span><br><span class="line"><span class="keyword">struct</span> page_address_map &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span>;</span></span><br><span class="line">	<span class="type">void</span> *virtual;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="get-free-page"><a href="#get-free-page" class="headerlink" title="get_free_page"></a>get_free_page</h3><p>​    与alloc_page(s)系列最大的区别是无法申请高端内存，因为它返回到是一个线性地址，而高端内存是需要额外映射才可以访问的。对应的释放函数是free_page。</p>
<hr>
<h1 id="Slab分配器"><a href="#Slab分配器" class="headerlink" title="Slab分配器"></a>Slab分配器</h1><p>​    伙伴算法采用的是多个物理页page的分配和管理，在分配内存时最小也有一个物理页(4K)，但是在实际开发中经常申请非常小的内存，可能就只有几个字节。如果为了申请几个字节而依然分配一个物理页，那么这个物理页中处理需要的几个字节之外，其他的部分都浪费了，即产生了<strong>内部碎片</strong>。就好比乘坐公交车仅需要一元，但是身上只有100元(一个物理页)，用100元投币。</p>
<blockquote>
<p>内部碎片：已经被分配出去的的内存空间大于请求所需的内存空间。</p>
</blockquote>
<p>​    为了解决小块内存的分配，Linux内核基于Solaris 2.4中的slab分配算法实现了自己的slab分配器，除此之外，slab分配器另一个主要功能是作为一个高速缓存，它用来存储内核中那些经常分配并释放的对象。</p>
<p>​    slab并没有脱离伙伴系统算法，而是基于伙伴系统分配的大内存基础上，进一步细分小内存对象的分配。</p>
<h2 id="slab分配器基本原理"><a href="#slab分配器基本原理" class="headerlink" title="slab分配器基本原理"></a>slab分配器基本原理</h2><p>​    在伙伴算法的基础上最小分配一个物理页，slab算法是针对小内存的内存分配机制，特点是基于对象进行管理。对象实际上指的是某一种数据类型，就是**<u>内核中的数据结构</u><strong>以及对</strong><u>数据结构进行创建和撤销的操作</u>**。</p>
<p>​    slab会将不同的对象划分成所谓的<strong>高速缓存</strong>(cache)组，每种对象对应着一个高速缓存(cache)。</p>
<blockquote>
<p>例如：一个高速缓存存放task_struct结构体，而另一个高速缓存存放struct inode结构体；</p>
</blockquote>
<p>​    每个高速缓存的内存区域被划分成很多个slab，每个slab由一个或多个连续的物理页框组成，而这些页框中包含了若干个该类型的对象，这些对象有些事已经分配的对象，也有些是空闲的对象。</p>
<blockquote>
<p>当为一个数据结构创建了cache之后，若干个尚未分配的对象被分配到cache中，一个cache中对象的数量取决于slab的大小，例如12KB的slab由三个连续的4KB页面组成，可以存储6个2KB的对象。起初cache中所有对象都是标记为空闲状态。当需要该类型的数据结构新对象时，分配器可以从cache上分配任何空闲对象以便满足请求。当一个空闲的对象被分配之后对象标记为used状态。</p>
</blockquote>
<p><img src="https://cdn.jsdelivr.net/gh/anyeyueren/picgoimg/studyImg/%E5%86%85%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6.png"></p>
<hr>
<h3 id="高速缓存数据结构"><a href="#高速缓存数据结构" class="headerlink" title="高速缓存数据结构"></a>高速缓存数据结构</h3><p>​    内核对每一种数据结构都创建了一个高速缓存，这个高速缓存数据结构是kmem_cache，若干个数据结构通过双向链表连接起来，注意链表头cache_chain是内核初始化时先创建出来的一个静态kmem_cache。</p>
<blockquote>
<p>cache_chain  &lt;&#x3D;&#x3D;&#x3D;&gt;  kmem_cache &lt;&#x3D;&#x3D;&#x3D;&gt; kmem_cache &lt;&#x3D;&#x3D;&#x3D;&gt; kmem_cache ……kmem_cache &lt;&#x3D;&#x3D;&#x3D;&gt; kmem_cache</p>
</blockquote>
<p>​    下面数kmem_cache的数据结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//\include\linux\slab.h</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache</span> &#123;</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> object_size;    <span class="comment">//该区域是本对象的原始长度</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> size;	<span class="comment">/* The aligned/padded/added on size  */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> align;	<span class="comment">/* Alignment as calculated */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;	<span class="comment">/* Active flags on the slab */</span></span><br><span class="line">	<span class="type">const</span> <span class="type">char</span> *name;	<span class="comment">/* Slab name for sysfs */</span></span><br><span class="line">	<span class="type">int</span> refcount;		<span class="comment">/* Use counter */</span></span><br><span class="line">	<span class="type">void</span> (*ctor)(<span class="type">void</span> *);	<span class="comment">/* Called on object slot creation */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">list</span>;</span>	     <span class="comment">/* 系统中所有slab组成的链表 */</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The slab lists for all objects.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kmem_cache_node</span> &#123;</span></span><br><span class="line">	<span class="type">spinlock_t</span> list_lock;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLAB</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_partial</span>;</span>	    <span class="comment">/* slab状态1: slab中有些在使用，有些是空闲 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_full</span>;</span>        <span class="comment">/* slab状态2: slab所有对象标记为使用 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">slabs_free</span>;</span>        <span class="comment">/* slab状态3: slab所有对象标记为空闲 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> free_objects;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> free_limit;</span><br><span class="line">	<span class="type">unsigned</span> <span class="type">int</span> colour_next;	<span class="comment">/* Per-node cache coloring */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> *<span class="title">shared</span>;</span>	<span class="comment">/* shared per node */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">array_cache</span> **<span class="title">alien</span>;</span>	<span class="comment">/* on other nodes */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> next_reap;	<span class="comment">/* updated without locking */</span></span><br><span class="line">	<span class="type">int</span> free_touched;		<span class="comment">/* updated without locking */</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> nr_partial;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">partial</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_SLUB_DEBUG</span></span><br><span class="line">	<span class="type">atomic_long_t</span> nr_slabs;</span><br><span class="line">	<span class="type">atomic_long_t</span> total_objects;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">full</span>;</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>​    从数据结构中有这几点需要注意：</p>
<ul>
<li><p>kmem_cache结构体中object_size字段的含义是结构体对象的大小；</p>
</li>
<li><p>每块高速缓存的所有slab有三个链表，分别是：满的(slab 的所有对象标记为使用)、空的(slab 上的所有对象标记为空闲)、部分(slab 上的对象有的标记为使用，有的标记为空闲)；</p>
<blockquote>
<p>slab 分配器首先尝试在<strong>部分为空</strong>的 slab 中用空闲对象来满足请求。如果不存在，则从<strong>空的</strong> slab 中分配空闲对象。如果没有空的 slab 可用，则从<strong>连续物理页面分配新的 slab</strong>，并将其分配给 cache；从这个 slab 上，再分配对象内存。</p>
</blockquote>
</li>
<li><p>每个slab都是由一个或者多个物理页组成的，这些物理页中分了很多个此类的对象，有些分配出去了，有些是空的。以object_size为128为例，该数据结构对象大小为128字节，那么对应slab对应的物理页中分成了若干个128字节的对象。如果现在需要分配一个128字节的对象，那么就从管理的众多object链表中取出一个空闲的使用，使用之后释放，该object从已分配转成空闲状态从新插入到object链表中；</p>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/anyeyueren/picgoimg/studyImg/slab%E7%BB%93%E6%9E%84.jpg"></p>
<hr>
<h2 id="slab机制的优点和作用"><a href="#slab机制的优点和作用" class="headerlink" title="slab机制的优点和作用"></a>slab机制的优点和作用</h2><p>slab的基本目标就是：</p>
<blockquote>
<ol>
<li>减少伙伴算法在分配小块连续内存时所产生的内部碎片；</li>
<li>将频繁使用的对象缓存起来，减少分配、初始化和释放对象的时间开销；</li>
<li>通过着色技术调整对象以更好的使用硬件高速缓存；</li>
</ol>
</blockquote>
<p>​    基本思想是将内核中经常使用的对象放到高速缓存中，并且由系统保持为初始的可利用状态。比如进程描述符，内核中会频繁对此数据进行申请和释放。</p>
<p>​    <strong>为什么slab分配器不会引起内存浪费？</strong></p>
<blockquote>
<p>因为每个内核数据结构都有关联的cache，每个cache都由一个或者多个slab可用，而slab将其对应的物理页按照对象的大小进行分块。因此当内核请求对象内存时，slab分配器可以返回刚好该对象大小所需的内存。</p>
</blockquote>
<p>​    <strong>为什么slab机制可以减少分配、初始化和释放对象的开销？</strong></p>
<blockquote>
<p>分配和释放内存的动作可能是一个耗时过程。然而，由于对象已预先创建，因此可以从 cache 中快速分配。再者，当内核用完对象并释放它时，它被标记为空闲并返回到 cache，从而立即可用于后续的内核请求。</p>
</blockquote>
<hr>
<h1 id="slob与slub"><a href="#slob与slub" class="headerlink" title="slob与slub"></a>slob与slub</h1><p>​    Linux 后来又发布另外两个内核内存分配器，SLOB 和 SLUB 分配器。</p>
<p>​    slob分配器用于有限内存的系统，例如嵌入式系统。SLOB 工作采用 3 个对象列表：小（用于小于 256 字节的对象）、中（用于小于 1024 字节的对象）和大（用于小于页面大小的对象）。内存请求采用首先适应策略，从适当大小的列表上分配对象。</p>
<h2 id="slab的不足"><a href="#slab的不足" class="headerlink" title="slab的不足"></a>slab的不足</h2><p>​    既然说slub是slab的优化，那么slab的不足之处在于：</p>
<ol>
<li>缓存队列管理复杂；</li>
<li>管理数据存储开销大；</li>
<li>对NUMA支持复杂；</li>
<li>摒弃了效果不太明显的slab着色机制；</li>
</ol>
<p>​    从版本 2.6.24 开始，SLUB 分配器取代 SLAB，成为 Linux 内核的默认分配器。SLUB 通过减少 SLAB 分配器所需的大量开销，来解决 slab 分配的性能问题，一个改变是，在 SLAB 分配下每个 slab 存储的元数据，移到 Linux 内核用于每个页面的结构 page。此外，对于 SLAB 分配器，每个 CPU 都有队列以维护每个 cache 内的对象，SLUB 会删除这些队列。</p>
<blockquote>
<p>简单的说：Slab是基础，是最早从Sun OS那引进的；Slub是在Slab上进行的改进，在大型机上表现出色（不知道在普通PC上如何），据说还被IA-64作为默认；而Slob是针对小型系统设计的，当然了，主要是嵌入式。</p>
</blockquote>
<hr>
<h2 id="slub机制"><a href="#slub机制" class="headerlink" title="slub机制"></a>slub机制</h2><p>​    SLUB分配器特点是简化设计理念，同时保留SLAB分配器的基本思想：每个缓冲区由多个小的slab 组成，每个 slab 包含固定数目的对象。SLUB分配器简化kmem_cache，slab等相关的管理数据结构，摒弃了SLAB 分配器中众多的队列概念，并针对多处理器、NUMA系统进行优化，从而提高了性能和可扩展性并降低了内存的浪费。为了保证内核其它模块能够无缝迁移到SLUB分配器，SLUB还保留了原有SLAB分配器所有的接口API函数。（此处有关于slub机制实现机制的源码剖析，仔细研读：<a target="_blank" rel="noopener" href="https://rtoax.blog.csdn.net/article/details/106440497">linux内核之slob、slab、slub</a>）</p>
<p><img src="https://cdn.jsdelivr.net/gh/anyeyueren/picgoimg/studyImg/slub%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84.png"></p>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Barret</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/05/03/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E5%9B%9B)/">http://example.com/2021/05/03/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E5%9B%9B)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Barret Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/03/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%BA%94)/"><img class="prev-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux环境内存管理(五)</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/02/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%B8%80)/"><img class="next-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux环境内存管理(一)</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F14206928472%2F1000.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650157497&amp;t=70dfbdc4919a4e744f090628aaf5059d" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Barret</div><div class="author-info__description">Welcome Visit</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">52</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/anyeyueren" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2412704562@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%A2%8E%E7%89%87"><span class="toc-number">1.</span> <span class="toc-text">内存碎片</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4-Buddy-%E7%AE%97%E6%B3%95"><span class="toc-number">2.</span> <span class="toc-text">伙伴(Buddy)算法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BC%99%E4%BC%B4%E7%AE%97%E6%B3%95%E5%8E%9F%E7%90%86"><span class="toc-number">2.1.</span> <span class="toc-text">伙伴算法原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%94%B3%E8%AF%B7%E5%92%8C%E5%9B%9E%E6%94%B6"><span class="toc-number">2.2.</span> <span class="toc-text">申请和回收</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">2.3.</span> <span class="toc-text">算法优缺点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">2.4.</span> <span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#zone"><span class="toc-number">2.4.1.</span> <span class="toc-text">zone</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#free-area"><span class="toc-number">2.4.2.</span> <span class="toc-text">free_area</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#rmqueue-smallest"><span class="toc-number">2.4.3.</span> <span class="toc-text">rmqueue_smallest</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#expand"><span class="toc-number">2.4.4.</span> <span class="toc-text">expand</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%B5%E6%A1%86%E6%93%8D%E4%BD%9C%E5%87%BD%E6%95%B0"><span class="toc-number">2.5.</span> <span class="toc-text">页框操作函数</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#alloc-pages"><span class="toc-number">2.5.1.</span> <span class="toc-text">alloc_pages()</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#get-free-page"><span class="toc-number">2.5.2.</span> <span class="toc-text">get_free_page</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Slab%E5%88%86%E9%85%8D%E5%99%A8"><span class="toc-number">3.</span> <span class="toc-text">Slab分配器</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#slab%E5%88%86%E9%85%8D%E5%99%A8%E5%9F%BA%E6%9C%AC%E5%8E%9F%E7%90%86"><span class="toc-number">3.1.</span> <span class="toc-text">slab分配器基本原理</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%AB%98%E9%80%9F%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">3.1.1.</span> <span class="toc-text">高速缓存数据结构</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slab%E6%9C%BA%E5%88%B6%E7%9A%84%E4%BC%98%E7%82%B9%E5%92%8C%E4%BD%9C%E7%94%A8"><span class="toc-number">3.2.</span> <span class="toc-text">slab机制的优点和作用</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#slob%E4%B8%8Eslub"><span class="toc-number">4.</span> <span class="toc-text">slob与slub</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#slab%E7%9A%84%E4%B8%8D%E8%B6%B3"><span class="toc-number">4.1.</span> <span class="toc-text">slab的不足</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#slub%E6%9C%BA%E5%88%B6"><span class="toc-number">4.2.</span> <span class="toc-text">slub机制</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2022/07/03/openHarmony/harmonyOS%E5%9B%BE%E5%BD%A2%E5%AD%90%E7%B3%BB%E7%BB%9F/" title="无题"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/07/03/openHarmony/harmonyOS%E5%9B%BE%E5%BD%A2%E5%AD%90%E7%B3%BB%E7%BB%9F/" title="无题">无题</a><time datetime="2022-07-03T14:36:41.658Z" title="发表于 2022-07-03 22:36:41">2022-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/07/03/openHarmony/harmonyOS%E6%A6%82%E8%BF%B0/" title="无题"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/07/03/openHarmony/harmonyOS%E6%A6%82%E8%BF%B0/" title="无题">无题</a><time datetime="2022-07-03T14:36:41.658Z" title="发表于 2022-07-03 22:36:41">2022-07-03</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2022/03/24/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/C%E8%AF%AD%E8%A8%80%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" title="无题"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="无题"/></a><div class="content"><a class="title" href="/2022/03/24/%E7%BC%96%E7%A8%8B%E8%A7%84%E8%8C%83/C%E8%AF%AD%E8%A8%80%E5%AE%89%E5%85%A8%E7%BC%96%E7%A0%81%E8%A7%84%E8%8C%83/" title="无题">无题</a><time datetime="2022-03-24T07:05:30.698Z" title="发表于 2022-03-24 15:05:30">2022-03-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E4%B8%83)/" title="进程同步和信号量"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程同步和信号量"/></a><div class="content"><a class="title" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E4%B8%83)/" title="进程同步和信号量">进程同步和信号量</a><time datetime="2021-11-24T22:04:16.000Z" title="发表于 2021-11-25 06:04:16">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%85%AB)/" title="信号量临界区保护"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信号量临界区保护"/></a><div class="content"><a class="title" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%85%AB)/" title="信号量临界区保护">信号量临界区保护</a><time datetime="2021-11-24T22:04:16.000Z" title="发表于 2021-11-25 06:04:16">2021-11-25</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Barret</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>