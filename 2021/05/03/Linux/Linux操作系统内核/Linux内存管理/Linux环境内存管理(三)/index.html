<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux环境内存管理(三) | Barret Blog</title><meta name="keywords" content="IT"><meta name="author" content="Barret"><meta name="copyright" content="Barret"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="内存描述符内核为系统中每一个进程都维护了一个数据结构**task_struct**，这个数据结构存储在内核空间当中。 这个结构体也可以被叫做进程描述符，内部的成员包含了很多与进程相关的信息。 12345678910struct task_struct &amp;#123;    long              state;          &#x2F;&#x2F; 进程状态    struct mm_struct  *">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux环境内存管理(三)">
<meta property="og:url" content="http://example.com/2021/05/03/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%B8%89)/index.html">
<meta property="og:site_name" content="Barret Blog">
<meta property="og:description" content="内存描述符内核为系统中每一个进程都维护了一个数据结构**task_struct**，这个数据结构存储在内核空间当中。 这个结构体也可以被叫做进程描述符，内部的成员包含了很多与进程相关的信息。 12345678910struct task_struct &amp;#123;    long              state;          &#x2F;&#x2F; 进程状态    struct mm_struct  *">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650272949&t=18f99d2e597ef4e5080a0e7cdc68b6e1">
<meta property="article:published_time" content="2021-05-03T12:04:16.000Z">
<meta property="article:modified_time" content="2022-03-23T00:38:25.501Z">
<meta property="article:author" content="Barret">
<meta property="article:tag" content="IT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650272949&t=18f99d2e597ef4e5080a0e7cdc68b6e1"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/05/03/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%B8%89)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux环境内存管理(三)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-23 08:38:25'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F14206928472%2F1000.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650157497&amp;t=70dfbdc4919a4e744f090628aaf5059d" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Barret Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux环境内存管理(三)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-03T12:04:16.000Z" title="发表于 2021-05-03 20:04:16">2021-05-03</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-23T00:38:25.501Z" title="更新于 2022-03-23 08:38:25">2022-03-23</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux环境内存管理(三)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="内存描述符"><a href="#内存描述符" class="headerlink" title="内存描述符"></a>内存描述符</h1><p>内核为系统中每一个进程都维护了一个数据结构**<u>task_struct</u>**，这个数据结构存储在内核空间当中。 这个结构体也可以被叫做进程描述符，内部的成员包含了很多与进程相关的信息。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line">    <span class="type">long</span>              state;          <span class="comment">// 进程状态</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span>  *<span class="title">mm</span>;</span>            <span class="comment">// 虚拟内存结构体，内存描述符</span></span><br><span class="line">    <span class="type">pid_t</span>             pid;            <span class="comment">// 进程号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> __<span class="title">rcu</span>  *<span class="title">parent</span>;</span>       <span class="comment">// 指向父进程的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>        <span class="title">children</span>;</span>        <span class="comment">// 子进程列表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">fs_struct</span>        *<span class="title">fs</span>;</span>          <span class="comment">// 存放文件系统信息的指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">files_struct</span>     *<span class="title">files</span>;</span>           <span class="comment">// 一个数组，包含该进程打开的文件指针</span></span><br><span class="line">    ......</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="段的分类"><a href="#段的分类" class="headerlink" title="段的分类"></a>段的分类</h2><p>​    前一章节说过进程通常都是加载一个elf文件启动的，而elf文件都是由若干个segments组成的。这里的段并不是物理意义上的段机制，是linux虚拟地址空间中用于保存数据的区域，仅在虚拟地址上连续。这些段</p>
<p>​    具体可以分为：text段、data段、bss段，heap段、stack段和内存映射段(memory mapping segment)。text段、data段和bss段这三个段式紧挨着的，并且大小固定不会发生变化。</p>
<p>​    heap段和stack段的大小都会随着进程运行过程变化，因此中间会留有空隙，**<u>heap往上增长，stack往下增长</u>**。</p>
<p>​    mmaping segmnet比较特殊，这个段处于heap和stack之间的一段空间，是由mmap()系统调用映射出来的。</p>
<blockquote>
<p><strong>mmap映射</strong>的大小也是不确定的。3GB的虚拟地址空间已经很大了，但heap段, stack段，mmap段在动态增长的过程还是有重叠（碰撞）的可能。为了避免重叠发生，通常将mmap映射段的起始地址选在TASK_SIZE&#x2F;3（也就是1GB）的位置。</p>
</blockquote>
<p>​    这些segments的加载顺序是怎样的呢？</p>
<blockquote>
<p>首先通过execve()执行elf，则该可执行文件的text段，data段，stack段就建立了，在进程运行过程中，可能需要借助ld.so加载动态链接库，比如最常用的libc，则libc.so的text段，data段也建立了，而后可能通过mmap()的匿名映射来实现与其他进程的共享内存，还有可能通过brk()来扩大heap段的大小。</p>
</blockquote>
<h2 id="mm-struct"><a href="#mm-struct" class="headerlink" title="mm_struct"></a>mm_struct</h2><p>进程描述符中用于描述虚拟内存信息的结构体 —— mm_struct，也叫作<strong>内存描述符</strong>。抽象出这样一个结构体用于描述linux下进程的地址空间所有信息，包含了整个虚拟地址空间。<br><img src="https://cdn.jsdelivr.net/gh/anyeyueren/picgoimg/studyImg/内存描述符.png" alt="malloc的chunk机制" style="zoom:60%;" /></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//mm_struct 描述一个进程的虚拟地址空间</span></span><br><span class="line"><span class="comment">//vm_area_struct 描述一个虚拟内存区域(VMA)   进程的虚拟地址空间由多个VMA组成</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span>		<span class="comment">/* 指向虚拟内存区域(VMA)链表 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span>               <span class="comment">/* 红黑树根节点，便于对vma管理查找 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap_cache</span>;</span>	<span class="comment">/* 指向最近找到的虚拟内存区域，加快查询速度*/</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_MMU <span class="comment">//该函数功能就是在内存映射区找到一个没有映射的区域</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="title function_">long</span> <span class="params">(*get_unmapped_area)</span> <span class="params">(<span class="keyword">struct</span> file *filp,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> addr, <span class="type">unsigned</span> <span class="type">long</span> len,</span></span><br><span class="line"><span class="params">				<span class="type">unsigned</span> <span class="type">long</span> pgoff, <span class="type">unsigned</span> <span class="type">long</span> flags)</span>;</span><br><span class="line">	<span class="type">void</span> (*unmap_area) (<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr);</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_base;		   <span class="comment">/* 内存映射区域的起始地址*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> mmap_legacy_base;    <span class="comment">/* base of mmap area in bottom-up allocations */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> task_size;		<span class="comment">/* 用户虚拟地址空间的长度 */</span> </span><br><span class="line">	<span class="type">pgd_t</span> * pgd;                        <span class="comment">/* 指向该进程的页目录表*/</span></span><br><span class="line">   </span><br><span class="line">	<span class="type">atomic_t</span> mm_users;			        <span class="comment">/* 用户空间中用户数目 */</span></span><br><span class="line">	<span class="type">atomic_t</span> mm_count;			        <span class="comment">/* 对&quot;struct mm_struct&quot;有多少引用  内存描述符引用计数器*/</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> total_vm;</span><br><span class="line">	<span class="type">int</span> map_count;				        <span class="comment">/* 虚拟内存区域的个数 */</span>    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">mmlist</span>;</span>            <span class="comment">/* 所有活动(active)的mm的链表*/</span></span><br><span class="line">	<span class="comment">/* 代码段起始地址和结束地址，数据段起始地址和结束地址 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="comment">/* 堆的首地址、堆的尾地址、栈首地址*/</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="comment">/* 命令行参数首地址、尾地址 */</span></span><br><span class="line">    <span class="comment">/* 环境变量首地址、尾地址 */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line">    <span class="type">mm_context_t</span> context;     <span class="comment">//处理器架构特定的内存管理上下文</span></span><br><span class="line">    ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p>mmap指向vma链表的头节点，mm_rb指向vma红黑树的根节点；</p>
</li>
<li><p>map_count是vma的总个数，total_vm是进程地址空间的总大小（以page为单位）；</p>
</li>
<li><p>mmap_cache保存了上一次找到的vma；</p>
</li>
</ul>
<h3 id="vm-area-struct"><a href="#vm-area-struct" class="headerlink" title="vm_area_struct"></a>vm_area_struct</h3><p>​    结构体vm_area_struct也是用来描述虚拟地址空间的一个区间，但是与mm_strcut相比是较低的一个层次。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//用来描述一个虚拟内存区域(VMA)</span></span><br><span class="line"><span class="comment">//内核将每个内存区域作为一个单独的内存对象管理，每个内存区域都有一致的属性</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start;		<span class="comment">/* 在进程虚拟地址空间中的起始地址. */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> vm_end;		<span class="comment">/* 在进程虚拟地址空间中的结束地址. */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span>  <span class="comment">/* 双向链表，连接前后 */</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span>       <span class="comment">/* 红黑树成员节点 */</span></span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span>      <span class="comment">/* 该虚拟内存区域所在的虚拟地址空间 */</span></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot;        <span class="comment">/* 这个VMA的存取访问权限 */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags;       <span class="comment">/* 虚拟内存区域的标志 */</span></span><br><span class="line">            <span class="comment">// VM_READ/VM_WRITE/VM_EXEC: 此虚拟内存区可读/可写/可执行;    </span></span><br><span class="line">            <span class="comment">// VM_SHARED: 此虚拟内存区域可在多个进程之间共享；</span></span><br><span class="line">            <span class="comment">// VM_IO: 此虚拟内存区域映射设备I/O空间；</span></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">/* 对这个虚拟内存区域进行操作的函数 */</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span>	      <span class="comment">/* 该vma映射的是哪一个文件，可以是NULL */</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;       <span class="comment">/* 文件中的偏移量 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>每个segmen用一个vm_area_struct(简称vma)结构体表示，vma是通过一个双向链表串起来的。现存的vma按照起始地址以递增次序被归入链表中，每个vma是这个链表里的一个节点；</li>
<li>同时，vma又通过<strong>红黑树</strong>（red black tree）组织起来，每个vma又是这个红黑树里的一个节点；</li>
</ul>
<blockquote>
<p>使用链表简单方便，但是通过查找链表找到与特定地址关联vma，其时间复杂度为O(N)，但是在现实应用中，在地址空间中查找vma又是非常频繁。使用红黑树数据结构可以显著减少查找所需的时间。</p>
</blockquote>
<ul>
<li><p>vm_start和vm_end分别是这个vma所指向区域的起始地址和结束地址，虽然vma是虚拟地址空间，但最终毕竟是要映射到物理内存上去的，所以也要求是4KB对齐的；</p>
</li>
<li><p>vm_flags描述的是vma的属性，flag可以是VM_READ、VM_WRITE、VM_EXEC、VM_SHARED，分别指定vma的内容是否可以读、写、执行，或者由几个进程共享；</p>
</li>
</ul>
<blockquote>
<p>页表PTE中也有类似的Read&#x2F;Write权限限制位，那它和vma中的这些标志位是什么关系呢？</p>
<p>答：vma由许多的虚拟pages组成，每个虚拟page需要经过page table的转换才能找到对应的物理页面。PTE中的Read&#x2F;Write位是由软件设置的，设置依据就是这个page所属的vma，因此一个vma设置的VM_READ&#x2F;VM_WRITE属性会复制到这个vma所含pages的PTE中。之后，硬件MMU就可以在地址翻译的过程中根据PTE的标志位来检测访问是否合法。</p>
</blockquote>
<ul>
<li>可执行文件和动态链接库的text段和data段是基于elf文件的，mmap对文件的映射也是对应外部存储介质中这个被映射的文件的，这两种情况下，vm_file指向这个被映射的文件，进而可获得该文件的inode信息，而”vm_pgoff”是这个段在该文件内的偏移；</li>
</ul>
<blockquote>
<p>对于text段，一般偏移就是0。对于heap段，stack段以及mmap的匿名映射，没有与之相对应的文件实体，此时”vm_file”就为NULL，”vm_pgoff”的值没有意义。</p>
</blockquote>
<hr>
<h1 id="线程间共享地址空间机制"><a href="#线程间共享地址空间机制" class="headerlink" title="线程间共享地址空间机制"></a>线程间共享地址空间机制</h1><p>在linux系统中，如果clone()时设置<strong>CLONE_VM</strong>标志，我们把这样的进程称作为线程，同一个进程中所有的线程都是共享虚拟地址空间的。对于fork()函数，他利用copy_mm()函数复制父进程的mm_struct，也就是current-&gt;mm域给其子进程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//目录：kernel/fork.c</span></span><br><span class="line"><span class="type">static</span> <span class="type">int</span> <span class="title function_">copy_mm</span><span class="params">(<span class="type">unsigned</span> <span class="type">long</span> clone_flags, <span class="keyword">struct</span> task_struct *tsk)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, *<span class="title">oldmm</span>;</span></span><br><span class="line">	<span class="type">int</span> retval;</span><br><span class="line"></span><br><span class="line">	tsk-&gt;min_flt = tsk-&gt;maj_flt = <span class="number">0</span>;</span><br><span class="line">	tsk-&gt;nvcsw = tsk-&gt;nivcsw = <span class="number">0</span>;</span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> CONFIG_DETECT_HUNG_TASK</span></span><br><span class="line">	tsk-&gt;last_switch_count = tsk-&gt;nvcsw + tsk-&gt;nivcsw;</span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br><span class="line">	tsk-&gt;mm = <span class="literal">NULL</span>;</span><br><span class="line">	tsk-&gt;active_mm = <span class="literal">NULL</span>;</span><br><span class="line">	<span class="comment">/* * Are we cloning a kernel thread?</span></span><br><span class="line"><span class="comment">	 * We need to steal a active VM for that..*/</span></span><br><span class="line">	oldmm = current-&gt;mm;         <span class="comment">//将当前进程的mm存下来</span></span><br><span class="line">	<span class="keyword">if</span> (!oldmm)</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (clone_flags &amp; CLONE_VM) &#123;         <span class="comment">//如果是创建一个线程</span></span><br><span class="line">		<span class="type">atomic_inc</span>(&amp;oldmm-&gt;mm_users);      <span class="comment">//将这个mm对应的users加一</span></span><br><span class="line">		mm = oldmm;</span><br><span class="line">		<span class="keyword">goto</span> good_mm;</span><br><span class="line">	&#125;</span><br><span class="line">	retval = -ENOMEM;</span><br><span class="line">	mm = dup_mm(tsk);         <span class="comment">//而对于普通创建的进程就会将tsk复制一份</span></span><br><span class="line">	<span class="keyword">if</span> (!mm)</span><br><span class="line">		<span class="keyword">goto</span> fail_nomem;</span><br><span class="line">good_mm:</span><br><span class="line">	tsk-&gt;mm = mm;         <span class="comment">//子进程(线程)的mm就是当前进程的mm</span></span><br><span class="line">	tsk-&gt;active_mm = mm;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">fail_nomem:</span><br><span class="line">	<span class="keyword">return</span> retval;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<hr>
<h1 id="内存映射mmap"><a href="#内存映射mmap" class="headerlink" title="内存映射mmap"></a>内存映射mmap</h1><p>​    mmap函数可以将一个文件映射到进程地址空间中，映射完毕后就能够对其进行读写。mmap比read&#x2F;write效率高，这体现在：<strong>mmap实现了对物理内存的直接访问</strong>。而read函数还有一个用户空间和内核空间数据拷贝的过程。这种拷贝是有时间开销的，尤其在大量数据拷贝时候。</p>
<h2 id="内核实现"><a href="#内核实现" class="headerlink" title="内核实现"></a>内核实现</h2><p>​    用户空间的mmap()函数会通过系统调用调用到内核的<strong>do_mmap</strong>()函数。do_mmap()函数会：</p>
<ul>
<li>先**<u>创建一个新的VMA并初始化</u><strong>，然后加入进程的虚拟地址空间里。先通过</strong>get_unmapped_area()**找到虚拟地址空间中一块空闲且大小满足要求的区域，分配给新的vma并设置其flag属性，然后返回该vma的虚拟地址；</li>
<li>然后调用底层的mmap()函数建立VMA和实际物理地址的联系(建立页表)；</li>
</ul>
<h2 id="驱动mmap实现"><a href="#驱动mmap实现" class="headerlink" title="驱动mmap实现"></a>驱动mmap实现</h2><p>​    设备驱动的mmap实现主要是：将这个物理设备的可操作区域映射到一个进程的虚拟地址空间。这样一来，用户空间就可以直接采用指针方式访问设备的可操作区域了。</p>
<p>​    在驱动中的mmap实现主要完成一件事：</p>
<ul>
<li>建立设备的可操作区域到进程虚拟空间地址的映射过程；</li>
<li>同时还需要保证这段映射的虚拟存储器区域不会被进程当做一般的空间使用，因此需要添加一系列保护方式；</li>
</ul>
<p>​    建立VMA和物理地址的映射的工作由<strong>remap_pfn_range</strong>来完成：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// vma: 需要建立映射的VMA</span></span><br><span class="line"><span class="comment">// virt_addr: 需要建立映射的VMA的起始地址 </span></span><br><span class="line"><span class="comment">// pfn: 页帧号，对应虚拟地址应当被映射的物理地址。这个页帧号简单就是物理地址右移PAGE_SHIFT位</span></span><br><span class="line"><span class="comment">// size: 需要建立映射的VMA大小，单位字节</span></span><br><span class="line"><span class="comment">// port: 使用在vma-&gt;vm_page_prot中找到值</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">remap_pfn_range</span><span class="params">(<span class="keyword">struct</span> vm_area_struct *vma, <span class="type">unsigned</span> <span class="type">long</span> addr,</span></span><br><span class="line"><span class="params">		            <span class="type">unsigned</span> <span class="type">long</span> pfn, <span class="type">unsigned</span> <span class="type">long</span> size, <span class="type">pgprot_t</span> prot)</span></span><br><span class="line">&#123;</span><br><span class="line">   ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="mmap-cache机制"><a href="#mmap-cache机制" class="headerlink" title="mmap_cache机制"></a>mmap_cache机制</h2><p>​    根据局部性原理，下一次要用到的vma正好是上次使用的vma的可能性是比较大的，因此使用<strong>find_vma</strong>()函数查找vma时，会首先从<strong>mmap_cache</strong>中找，找到了就直接返回；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//find_vma函数：先查cache，若没有查到再通过红黑树进行遍历查找</span></span><br><span class="line"><span class="keyword">struct</span> vm_area_struct *<span class="title function_">find_vma</span><span class="params">(<span class="keyword">struct</span> mm_struct *mm, <span class="type">unsigned</span> <span class="type">long</span> addr)</span></span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma</span> =</span> <span class="literal">NULL</span>;   <span class="comment">//存放查找到的vma</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Check the cache first. */</span></span><br><span class="line">	<span class="comment">/* (Cache hit rate is typically around 35%.) */</span></span><br><span class="line">	vma = ACCESS_ONCE(mm-&gt;mmap_cache);   </span><br><span class="line">	<span class="keyword">if</span> (!(vma &amp;&amp; vma-&gt;vm_end &gt; addr &amp;&amp; vma-&gt;vm_start &lt;= addr)) &#123; <span class="comment">//若addr不在cache的vma地址范围内则遍历</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> *<span class="title">rb_node</span>;</span></span><br><span class="line"></span><br><span class="line">		rb_node = mm-&gt;mm_rb.rb_node;</span><br><span class="line">		vma = <span class="literal">NULL</span>;</span><br><span class="line">       <span class="comment">//遍历红黑树</span></span><br><span class="line">		<span class="keyword">while</span> (rb_node) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vma_tmp</span>;</span></span><br><span class="line">			vma_tmp = rb_entry(rb_node, <span class="keyword">struct</span> vm_area_struct, vm_rb);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (vma_tmp-&gt;vm_end &gt; addr) </span><br><span class="line">            &#123;</span><br><span class="line">				vma = vma_tmp;</span><br><span class="line">				<span class="keyword">if</span> (vma_tmp-&gt;vm_start &lt;= addr)</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				rb_node = rb_node-&gt;rb_left;</span><br><span class="line">			&#125; </span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">				rb_node = rb_node-&gt;rb_right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (vma)</span><br><span class="line">			mm-&gt;mmap_cache = vma;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> vma;  <span class="comment">//查找的vma正是此vma则返回该vma</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但是实际上这种mmap_cache的命中率通常只有35%-50%，之后内核开发者又在此基础上，设计了<a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/99124666">新的VMA cache方案</a>。</p>
<h1 id="虚拟内存区分析"><a href="#虚拟内存区分析" class="headerlink" title="虚拟内存区分析"></a>虚拟内存区分析</h1><p>​    本节将从实际操作查看虚拟内存各个区域。先编写一个简单的代码，代码中获取进程pid号，让进程一直处于运行状态。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//运行代码</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;PID = %d\n&quot;</span>,getpid());</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">         sleep(<span class="number">2</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//根据打印的进程号查看: /proc/进程号/maps</span></span><br><span class="line">[root@centos7 ~]<span class="meta"># cat /proc/1644/maps </span></span><br><span class="line"><span class="number">00400000</span><span class="number">-00401000</span> r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">03</span> <span class="number">269044748</span>                          /home/Test/a.out</span><br><span class="line"><span class="number">00600000</span><span class="number">-00601000</span> r--p <span class="number">00000000</span> <span class="number">08</span>:<span class="number">03</span> <span class="number">269044748</span>                          /home/Test/a.out</span><br><span class="line"><span class="number">00601000</span><span class="number">-00602000</span> rw-p <span class="number">00001000</span> <span class="number">08</span>:<span class="number">03</span> <span class="number">269044748</span>                          /home/Test/a.out</span><br><span class="line"><span class="number">7f</span>0e0c96e000<span class="number">-7f</span>0e0cb31000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">03</span> <span class="number">1306</span>                       /usr/lib64/libc<span class="number">-2.17</span>.so</span><br><span class="line"><span class="number">7f</span>0e0cb31000<span class="number">-7f</span>0e0cd31000 ---p <span class="number">001</span>c3000 <span class="number">08</span>:<span class="number">03</span> <span class="number">1306</span>                       /usr/lib64/libc<span class="number">-2.17</span>.so</span><br><span class="line"><span class="number">7f</span>0e0cd31000<span class="number">-7f</span>0e0cd35000 r--p <span class="number">001</span>c3000 <span class="number">08</span>:<span class="number">03</span> <span class="number">1306</span>                       /usr/lib64/libc<span class="number">-2.17</span>.so</span><br><span class="line"><span class="number">7f</span>0e0cd35000<span class="number">-7f</span>0e0cd37000 rw-p <span class="number">001</span>c7000 <span class="number">08</span>:<span class="number">03</span> <span class="number">1306</span>                       /usr/lib64/libc<span class="number">-2.17</span>.so</span><br><span class="line"><span class="number">7f</span>0e0cd37000<span class="number">-7f</span>0e0cd3c000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="number">7f</span>0e0cd3c000<span class="number">-7f</span>0e0cd5e000 r-xp <span class="number">00000000</span> <span class="number">08</span>:<span class="number">03</span> <span class="number">1299</span>                       /usr/lib64/ld<span class="number">-2.17</span>.so</span><br><span class="line"><span class="number">7f</span>0e0cf51000<span class="number">-7f</span>0e0cf54000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="number">7f</span>0e0cf5b000<span class="number">-7f</span>0e0cf5d000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="number">7f</span>0e0cf5d000<span class="number">-7f</span>0e0cf5e000 r--p <span class="number">00021000</span> <span class="number">08</span>:<span class="number">03</span> <span class="number">1299</span>                       /usr/lib64/ld<span class="number">-2.17</span>.so</span><br><span class="line"><span class="number">7f</span>0e0cf5e000<span class="number">-7f</span>0e0cf5f000 rw-p <span class="number">00022000</span> <span class="number">08</span>:<span class="number">03</span> <span class="number">1299</span>                       /usr/lib64/ld<span class="number">-2.17</span>.so</span><br><span class="line"><span class="number">7f</span>0e0cf5f000<span class="number">-7f</span>0e0cf60000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span> </span><br><span class="line"><span class="number">7f</span>fd3d0c2000<span class="number">-7f</span>fd3d0e3000 rw-p <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [<span class="built_in">stack</span>]</span><br><span class="line"><span class="number">7f</span>fd3d1a9000<span class="number">-7f</span>fd3d1ab000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                          [vdso]</span><br><span class="line">ffffffffff600000-ffffffffff601000 r-xp <span class="number">00000000</span> <span class="number">00</span>:<span class="number">00</span> <span class="number">0</span>                  [vsyscall]</span><br><span class="line"></span><br><span class="line"> <span class="comment">//08:03的含义</span></span><br><span class="line">[root@centos7 ~]<span class="meta"># ls -l /dev/     </span></span><br><span class="line">total <span class="number">0</span></span><br><span class="line">......</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk      <span class="number">8</span>,   <span class="number">0</span> May  <span class="number">3</span> <span class="number">16</span>:<span class="number">56</span> sda</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk      <span class="number">8</span>,   <span class="number">1</span> May  <span class="number">3</span> <span class="number">16</span>:<span class="number">56</span> sda1</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk      <span class="number">8</span>,   <span class="number">2</span> May  <span class="number">3</span> <span class="number">16</span>:<span class="number">56</span> sda2</span><br><span class="line">brw-rw----. <span class="number">1</span> root disk      <span class="number">8</span>,   <span class="number">3</span> May  <span class="number">3</span> <span class="number">16</span>:<span class="number">56</span> sda3     #<span class="number">08</span>:<span class="number">03</span>含义就是磁盘</span><br><span class="line">......</span><br></pre></td></tr></table></figure>

<p>​    从maps文件中回显的内容看：</p>
<ul>
<li>总共的列数是6列：</li>
</ul>
<table>
<thead>
<tr>
<th>列</th>
<th>含义</th>
</tr>
</thead>
<tbody><tr>
<td>第一列：00400000-0040100</td>
<td>第一列是此段虚拟地址空间<strong>起始地址vm_start</strong>和<strong>结束地址vm_end</strong>；</td>
</tr>
<tr>
<td>第二列：r-xp</td>
<td>vm_flags表示虚拟地址空间的属性，每一种属性用一个字段表示，r表示可读，w表示可写，x表示可执行，p和s共用一个字段表示互斥关系，p表示私有段，s表示共享段；</td>
</tr>
<tr>
<td>第三列：00001000</td>
<td>vm_pgoff对于有名映射，表示此段虚拟内存起始地址在文件中以页（4k）为单位的偏移；对于匿名映射，等于0或者vm_start &#x2F; PAGE_SIZE;</td>
</tr>
<tr>
<td>第四列：08:03</td>
<td>映射文件设备号(vm_file-&gt;f_dentry-&gt;d_inode-&gt;i_sb-&gt;s_dev)，对于匿名映射来说，因为没有文件在磁盘上，所以没有设备号，始终为00:00；对于有名映射来说，就是映射的文件的节点号；</td>
</tr>
<tr>
<td>第五列：269044748</td>
<td>映射文件所属节点号，对于匿名映射来说，因为没有文件在磁盘上，所以没有节点号，始终为00:00；对于有名映射来说，是映射的文件的节点号；</td>
</tr>
<tr>
<td>第六列：&#x2F;usr&#x2F;lib64&#x2F;libc-2.17.so</td>
<td>对于有名来说，是映射文件名；对于匿名映射来说，是此段虚拟内存在进程中的角色，【stack】表示在进程中作为栈使用，【heap】表示堆，其余情况无显示；</td>
</tr>
</tbody></table>
<h1 id="内存相关源码数据结构"><a href="#内存相关源码数据结构" class="headerlink" title="内存相关源码数据结构"></a>内存相关源码数据结构</h1></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Barret</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/05/03/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%B8%89)/">http://example.com/2021/05/03/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%B8%89)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Barret Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/06/C++/C++%E7%9A%84%E5%BC%95%E7%94%A8/"><img class="prev-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">C++引用(一)</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/03/C++%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/%E5%A4%9A%E6%80%81%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86/"><img class="next-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">多态实现原理</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F14206928472%2F1000.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650157497&amp;t=70dfbdc4919a4e744f090628aaf5059d" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Barret</div><div class="author-info__description">Welcome Visit</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/anyeyueren" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2412704562@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">1.</span> <span class="toc-text">内存描述符</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E7%9A%84%E5%88%86%E7%B1%BB"><span class="toc-number">1.1.</span> <span class="toc-text">段的分类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mm-struct"><span class="toc-number">1.2.</span> <span class="toc-text">mm_struct</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#vm-area-struct"><span class="toc-number">1.2.1.</span> <span class="toc-text">vm_area_struct</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%BA%BF%E7%A8%8B%E9%97%B4%E5%85%B1%E4%BA%AB%E5%9C%B0%E5%9D%80%E7%A9%BA%E9%97%B4%E6%9C%BA%E5%88%B6"><span class="toc-number">2.</span> <span class="toc-text">线程间共享地址空间机制</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E6%98%A0%E5%B0%84mmap"><span class="toc-number">3.</span> <span class="toc-text">内存映射mmap</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E6%A0%B8%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.1.</span> <span class="toc-text">内核实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A9%B1%E5%8A%A8mmap%E5%AE%9E%E7%8E%B0"><span class="toc-number">3.2.</span> <span class="toc-text">驱动mmap实现</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#mmap-cache%E6%9C%BA%E5%88%B6"><span class="toc-number">3.3.</span> <span class="toc-text">mmap_cache机制</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98%E5%8C%BA%E5%88%86%E6%9E%90"><span class="toc-number">4.</span> <span class="toc-text">虚拟内存区分析</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%9B%B8%E5%85%B3%E6%BA%90%E7%A0%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-number">5.</span> <span class="toc-text">内存相关源码数据结构</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E4%B8%83)/" title="进程同步和信号量"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程同步和信号量"/></a><div class="content"><a class="title" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E4%B8%83)/" title="进程同步和信号量">进程同步和信号量</a><time datetime="2021-11-24T22:04:16.000Z" title="发表于 2021-11-25 06:04:16">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%85%AB)/" title="信号量临界区保护"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信号量临界区保护"/></a><div class="content"><a class="title" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%85%AB)/" title="信号量临界区保护">信号量临界区保护</a><time datetime="2021-11-24T22:04:16.000Z" title="发表于 2021-11-25 06:04:16">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/29/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%85%AD)/" title="CPU调度策略"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPU调度策略"/></a><div class="content"><a class="title" href="/2021/10/29/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%85%AD)/" title="CPU调度策略">CPU调度策略</a><time datetime="2021-10-28T22:04:16.000Z" title="发表于 2021-10-29 06:04:16">2021-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E4%BA%94)/" title="内核级线程"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内核级线程"/></a><div class="content"><a class="title" href="/2021/10/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E4%BA%94)/" title="内核级线程">内核级线程</a><time datetime="2021-10-24T22:04:16.000Z" title="发表于 2021-10-25 06:04:16">2021-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/17/C++%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="智能指针"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="智能指针"/></a><div class="content"><a class="title" href="/2021/10/17/C++%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="智能指针">智能指针</a><time datetime="2021-10-16T22:04:16.000Z" title="发表于 2021-10-17 06:04:16">2021-10-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Barret</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>