<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>Linux环境内存管理(一) | Barret Blog</title><meta name="keywords" content="IT"><meta name="author" content="Barret"><meta name="copyright" content="Barret"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="操作系统简介现代计算机系统是一个复杂的系统，其硬件由处理器、主存、磁盘以及若干输入输出设备组成，如果每个应用程序员都必须对计算机系统所有细节掌握完全，那么会大大降低开发效率，为了管理这些部件并加以优化使用，计算机必须安装一个软件 —— 操作系统。 计算机系统包含了的操作系统程序集合中，最重要的程序成为内核(kernel)。当操作系统启动时，内核装入到RAM中，内核中包含了系统运行必不可少的核心程序">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux环境内存管理(一)">
<meta property="og:url" content="http://example.com/2021/05/02/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%B8%80)/index.html">
<meta property="og:site_name" content="Barret Blog">
<meta property="og:description" content="操作系统简介现代计算机系统是一个复杂的系统，其硬件由处理器、主存、磁盘以及若干输入输出设备组成，如果每个应用程序员都必须对计算机系统所有细节掌握完全，那么会大大降低开发效率，为了管理这些部件并加以优化使用，计算机必须安装一个软件 —— 操作系统。 计算机系统包含了的操作系统程序集合中，最重要的程序成为内核(kernel)。当操作系统启动时，内核装入到RAM中，内核中包含了系统运行必不可少的核心程序">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650272949&t=18f99d2e597ef4e5080a0e7cdc68b6e1">
<meta property="article:published_time" content="2021-05-02T12:04:16.000Z">
<meta property="article:modified_time" content="2022-03-21T12:59:26.490Z">
<meta property="article:author" content="Barret">
<meta property="article:tag" content="IT">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&refer=http%3A%2F%2Fup.enterdesk.com&app=2002&size=f9999,10000&q=a80&n=0&g=0n&fmt=auto?sec=1650272949&t=18f99d2e597ef4e5080a0e7cdc68b6e1"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://example.com/2021/05/02/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%B8%80)/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":50},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'Linux环境内存管理(一)',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2022-03-21 20:59:26'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          if (t === 'dark') activateDarkMode()
          else if (t === 'light') activateLightMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><meta name="generator" content="Hexo 6.0.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F14206928472%2F1000.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650157497&amp;t=70dfbdc4919a4e744f090628aaf5059d" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Barret Blog</a></span><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> Home</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> Archives</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> Tags</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> Categories</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> List</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/link/"><i class="fa-fw fas fa-link"></i><span> Link</span></a></li><li><a class="site-page child" href="/about/"><i class="fa-fw fas fa-heart"></i><span> About</span></a></li></ul></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">Linux环境内存管理(一)</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2021-05-02T12:04:16.000Z" title="发表于 2021-05-02 20:04:16">2021-05-02</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-03-21T12:59:26.490Z" title="更新于 2022-03-21 20:59:26">2022-03-21</time></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="Linux环境内存管理(一)"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="操作系统简介"><a href="#操作系统简介" class="headerlink" title="操作系统简介"></a>操作系统简介</h1><p>现代计算机系统是一个复杂的系统，其硬件由处理器、主存、磁盘以及若干输入输出设备组成，如果每个应用程序员都必须对计算机系统所有细节掌握完全，那么会大大降低开发效率，为了管理这些部件并加以优化使用，计算机必须安装一个软件 —— 操作系统。</p>
<p>计算机系统包含了的操作系统程序集合中，最重要的程序成为内核(kernel)。当操作系统启动时，内核装入到RAM中，内核中包含了系统运行必不可少的核心程序。当然还有很多其他不太重要的程序，但是系统根本的能力是由内核决定的。</p>
<blockquote>
<p>操作系统必须要完成的目标：</p>
<ul>
<li><p>往下是与硬件部分交互，为包含在硬件平台上的所有低层可编程部件提供服务；</p>
</li>
<li><p>为计算机上的应用程序提供执行环境；</p>
</li>
</ul>
</blockquote>
<p>操作系统的任务就是为用户程序提供一个更好、更简单、更清晰的计算机模型，管理所有硬件资源。</p>
<p><img src="https://cdn.jsdelivr.net/gh/anyeyueren/picgoimg/studyImg/linux%E7%B3%BB%E7%BB%9F%E7%BB%93%E6%9E%84.png"></p>
<p>​    上图中整体分为<strong>硬件</strong>和<strong>软件</strong>，而软件部分又分为<u><strong>用户空间</strong></u>和**<u>内和空间</u>**，又称为用户态和内核态，而操作系统就运行在内核态。有且只有操作系统具有对硬件的完全访问权，可以执行机器能够运行的任何指令。实际上内核空间和用户空间之间还有一个用户接口程序 :shell或者GUI。</p>
<p>​    为了从操作系统中获得服务，用户程序必须使用<u><strong>系统调用(system call)</strong></u>陷入内核并调用操作系统。TRAP指令把用户态切换成内核态，并启用操作系统。当有关工作完成之后，系统调用后面的指令将控制权返还给用户程序。</p>
<p>​    Linux内核的整体架构，主要分为：<strong>进程管理(调度)<strong>、</strong>内存管理</strong>、<strong>虚拟文件系统(VFS)<strong>、</strong>设备驱动</strong>、<strong>网络子系统</strong>。</p>
<table>
<thead>
<tr>
<th>模块</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td>进程调度</td>
<td>负责管理CPU资源，以便让各个进程可以尽量公平的方式访问CPU；</td>
</tr>
<tr>
<td>内存管理</td>
<td>负责管理内存资源，以便让各个进程可以安全的共享机器的内存资源；<br/>内存管理会提供虚拟内存机制，可以让进程可用的内存多于系统的可用内存；</td>
</tr>
<tr>
<td>虚拟文件系统</td>
<td>Linux系统中“一切皆是文件”；</td>
</tr>
<tr>
<td>设备驱动</td>
<td>负责管理第三方设备接入&#x2F;终端(硬件设备提供的驱动)；</td>
</tr>
<tr>
<td>网络子系统</td>
<td>负责管理系统的网络设备，并实现多种多样的网络标准；</td>
</tr>
</tbody></table>
<hr>
<h2 id="linux内存概述"><a href="#linux内存概述" class="headerlink" title="linux内存概述"></a>linux内存概述</h2><p>​    众所周知，程序需要加载到<strong>物理内存</strong>才能运行，<strong>多核时代</strong>会出现多个进程同时操作同一物理地址的情况，进而造成混乱和<strong>程序崩溃</strong>。计算机当中很多问题的解决都是通过引入中间层，为解决物理内存使用问题，<strong>虚拟内存</strong>作为<strong>中间层</strong>进入了操作系统，从此，程序不在直接操作物理内存，只能看到虚拟内存，通过虚拟内存，非常优雅的将<strong>进程环境隔离</strong>开来，<strong>每个进程都拥有自己独立的虚拟地址空间</strong>，且所有进程地址空间范围完全一致，也给编程带来了很大的便利，同时也提高了物理内存的<strong>使用率</strong>，可同时运行更多的进程。</p>
<p>​    虚拟内存以<strong>页</strong>为单位进行划分，每个页对应物理内存上的<strong>页框</strong>（通常大小为4KB），<strong>内存管理单元（MMU）负责将虚拟地址转换为物理地址</strong>，MMU中有一张<strong>页表</strong>来存储这些映射关系。</p>
<p><strong>并非虚拟内存中所有的页都会分配对应的物理内存</strong>，为充分利用物理内存，保证尽可能多的进程运行在操作系统上，因此需要提高<strong>物理内存利用率</strong>，对于很少用到的虚拟内存页不分配对应的物理内存，只有用到的页分配物理内存。虽然从程序角度来看，<strong>虚拟内存为连续地址空间</strong>，但其实，它被分隔成多个<strong>物理内存碎片</strong>，甚至还有部分数据并<strong>不在内存</strong>中，而是在磁盘上。</p>
<p>当访问虚拟内存时，通过MMU寻找与之对应的物理内存，如果没有找到，操作系统会触发<strong>缺页中断</strong>，从磁盘中取得所缺的页并将其<strong>换入</strong>物理内存，并在页表中建立虚拟页与物理页的映射关系。</p>
<p>如果物理内存满了，操作系统会根据某种<strong>页面置换算法</strong>（比如LRU算法），将物理内存对应的页<strong>换出</strong>到磁盘，如果被换出的物理内存被修改过，则必须将其<strong>写回磁盘</strong>以更新对应的副本。</p>
<p>当进程创建时，内核为进程分配<strong>4G虚拟内存</strong>，此时，仅仅只是建立一个<strong>映射关系</strong>，程序的数据和代码都还在磁盘中，只有当运行时才换回物理内存。并且，通过<code>malloc</code>来分配动态内存时，也只分配了虚拟内存，并不会直接给物理内存，因此，理论上来说<code>malloc</code>可分配的内存大小应该是无限制的（实际当然会有很多算法进行限制）。</p>
<p><strong>内核</strong>通过<code>brk</code>和<code>mmap</code>来分配（虚拟）内存，<code>malloc/free</code>底层实现即为<code>brk</code>, <code>mmap</code>和<code>unmmap</code></p>
<p>当<strong>malloc内存小于128k</strong>时采用<code>brk</code>，其通过将数据段(.data)的地址指针<code>_edata</code>往高地址推来分配内存，<code>brk</code>分配的内存需要高地址内存全部释放后才会释放，当最高地址空间空闲内存大于128K时，执行内存紧缩操作。</p>
<p>当<strong>malloc内存大于128K</strong>时采用<code>mmap</code>，其在堆栈中间的<strong>文件映射区域</strong>（Memory Mapping Segment）找空闲虚拟内存，<code>mmap</code>分配的内存可单独释放。</p>
<p>每个进程都对应一个<code>mm_struct</code>结构体,即<strong>唯一的进程地址空间</strong>。为了解决内存碎片问题，进一步引入了slab机制和伙伴算法。</p>
<hr>
<h1 id="内存管理"><a href="#内存管理" class="headerlink" title="内存管理"></a>内存管理</h1><p>​        内存(RAM)是计算机中非常重要的资源，内存管理(Memory Manager,MM)模块主要提供内存资源的访问控制。如果不使用内存管理，即把物理地址直接暴露给进程就会带来很多严重问题：</p>
<ul>
<li><strong>破坏操作系统</strong>：用户程序可以寻址内存中每一个字节，容易破坏操作系统；</li>
<li><strong>地址空间不隔离</strong>：如果多个程序操作相同的地址空间会相互影响导致崩溃；</li>
<li><strong>程序运行地址不确定</strong>：程序运行时，都需要分配空闲区域，而空闲位置无法确定会带来重定位问题；</li>
</ul>
<h1 id="寻址"><a href="#寻址" class="headerlink" title="寻址"></a>寻址</h1><p>​    简单的理解寻址就是：磁头在盘片上定位数据的一个过程，是数据恢复技术的基础。</p>
<h2 id="物理寻址"><a href="#物理寻址" class="headerlink" title="物理寻址"></a>物理寻址</h2><p>​    一段代码通过编译链接之后就成了一个可执行的程序，存在在计算机的磁盘上，当可执行程序被运行时才会被加载到内存当中，进而再进入寄存器，CPU执行机器操作指令。这时候一个静态的程序才变成了一个进程。</p>
<p>​    物理寻址就是CPU执行机器指令时访问内存的过程，这也是最为自然的方式。</p>
<p><img src="https://cdn.jsdelivr.net/gh/anyeyueren/picgoimg/studyImg/CPU%E7%9B%B4%E6%8E%A5%E8%AE%BF%E9%97%AE%E7%89%A9%E7%90%86%E5%9C%B0%E5%9D%80.png"></p>
<p>​    图中读取从物理地址4处开始的4字节字。当CPU执行这条加载指令时，会生成一个有效的物理地址，通过内存总线传递给主存；主存读取从地址4处开始的4字节字返回给CPU，CPU将读取到的内容存放在寄存器中。这便是物理寻址的过程。</p>
<p>​    程序能寻址的范围是有限的，这取决于CPU的地址线条数。比如在32位平台下，寻址的范围是2^32也就是4G。并且这是固定的。如果没有虚拟内存，每个进程都能直接访问4G的物理内存显然不合理！</p>
<hr>
<h2 id="虚拟寻址"><a href="#虚拟寻址" class="headerlink" title="虚拟寻址"></a>虚拟寻址</h2><p>​    系统中的进程是与其他进程共享CPU和主存资源的，这样一来当系统中进程太多了就会导致一些进程无空间可以使用，这时内存就很容易破坏。为了更加有效地管理内存并减少出错，系统提供了一个对于主存的抽象概念叫做**<u>虚拟内存(VM)</u>**。虚拟寻址就是使用了虚拟内存机制的系统中，CPU执行指令访问内存的过程。</p>
<h2 id="内存地址"><a href="#内存地址" class="headerlink" title="内存地址"></a>内存地址</h2><p>​    程序员在操作内存时必须要区分这三种地址：<strong>逻辑地址</strong>、<strong>线性地址</strong>和<strong>物理地址</strong>。</p>
<p>​                          逻辑地址 ——-<strong><u>分段机制</u></strong>———&gt;  线性地址  ——–<strong><u>分页机制</u></strong>———–&gt;  物理地址</p>
<ul>
<li><strong>逻辑地址</strong></li>
</ul>
<p>C语言中的指针变量本身数值(即对变量取值&amp;)的地址就是逻辑地址。逻辑地址都是由一个**段(segment)<strong>和</strong>偏移量(offset)**组成，偏移量 指明了从段开始的地方到实际地址之间的距离。逻辑地址就是相对于当前进程数据段的地址。 应用程序员仅仅与逻辑地址打交道，只能在操作系统给分配的内存段操作。</p>
<p>逻辑地址分配更加灵活，可以允许不唯一，看起来也较为直观。一段代码中分配数组，逻辑地址上是连续的，然而在物理地址上，这个数组所占用的页可能分散开来，物理地址上就是不连续的，这样对程序的可理解性上有影响。</p>
<p>逻辑地址由**<u>段选择符</u><strong>和段内地址偏移量组成，段选择符存放在</strong>段寄存器**当中，这也是段寄存器唯一作用。这样做的目的是方便快速查找到段选择符。段寄存器有：cs，ss，ds，es，fs和gs。只有后三个可以作为一般用途，可以指向任意的数据段！</p>
<blockquote>
<p>cs：代码段寄存器，指向包含程序指令的段；</p>
<p>​        另外其含有一个两位的字段用来指明CPU的当前特权，0最高，3最低。Linux只用0级和3级，分别是内核态和用户态；</p>
<p>ss：栈段寄存器，指向包含当前程序栈的段；</p>
<p>ds：数据段寄存器，指向包含静态数据或者全局数据段；</p>
</blockquote>
<ul>
<li><strong>线性地址</strong>（<strong>虚拟地址</strong>）</li>
</ul>
<p>线性地址是一个32位无符号整数，可以用来表示高达4GB的地址，数值范围就是0x00000000 ~ 0xffffffff。线性地址是逻辑地址和物理地址的中间层。 MMU通过一个分段单元的硬件电路将逻辑地址转换成线性地址。</p>
<ul>
<li><strong>物理地址</strong></li>
</ul>
<p>线性地址经过分页单元的硬件电路就能将线性地址转换成物理地址。</p>
<hr>
<h1 id="分段机制"><a href="#分段机制" class="headerlink" title="分段机制"></a>分段机制</h1><p>​    关于内存访问有分段、分页、还有段页式。分段和分页都是操作系统为了更好的使用内存资源，这些并不是凭空想象创造出来的，是操作系统发展过程中一步一步演化而来。</p>
<blockquote>
<p>世界上第一块微处理器4004只是一个4位处理器，随后又推出8080，8位处理器，当时访问内存就是最直接的方法，直接访问物理地址！所以的内存访问就是通过绝对物理地址去访问，此时没有段的概念。</p>
<p>当8086(16位处理器)出现时，段的概念也随之被提出来。8086中寄存器只有16位，但是地址总线是20位。这就带来问题：如何使用16位寄存器访问20位地址。于是引入段的概念，让CPU通过[ 段基地址  +   段内偏移 ]访问内存。</p>
<p>即： 段基地址左移四位(乘以16)再加上段内偏移得到了20位地址。</p>
<p>例如： 如果要访问的内存地址是0x05808，那么段基地址可以是 0x0580，偏移量就是 0x0008。</p>
</blockquote>
<p>​    “段”的概念很好理解，其实就是因为寄存器只有 16 位一段只能访问 64 KB，所以需要移动基地址，一段一段的去访问所有的内存空间。用户空间中段可以分为：数据段(data segment)、代码段(code segment)、栈区段(stack segment)、堆区段(heap segment)和映射区段等。</p>
<h2 id="保护模式和实模式"><a href="#保护模式和实模式" class="headerlink" title="保护模式和实模式"></a>保护模式和实模式</h2><p>​    早期还没有考虑安全性问题，<strong>段寄存器</strong>中直接存放<strong>段基地址</strong>。此时并没有虚拟地址空间，程序与程序之间没有地址隔离，是可以相互访问对方程序地址的，很不安全！ 这种没有判断权限机制的就是<strong>实模式</strong>。</p>
<p>​    于是出现了<strong>保护模式</strong>，起到了当CPU访问地址时做一定约束的作用，会判断地址是否在允许的范围内，会判断当前的程序对目的地址是否有访问权限。这时候段寄存器中不再直接存放段基地址了，而是存放<strong>段选择符</strong>。<strong>段基地址</strong>存放在<strong>段描述符</strong>中，而的段描述符存放在GDT或者LDT中。(下文有详细描述)</p>
<blockquote>
<p>段选择符中T1 就是标明要去哪个表找，而 RPL 就是特权级。当地址访问时，如果 RPL 的权限低于目标特权级（DPL）时，就会拒绝访问，于是就起到了保护的作用。</p>
</blockquote>
<p>​    再后来出现了80286，也是第一代32位处理器，除了段寄存器还是 16 位之外，地址总线和寄存器都是 32 位，这就意味着以前为了寻址搞的段机制其实没用了。因为单单段内偏移就可以访问到 4GB 空间，但是为了<strong>向前兼容</strong>段机制还是保留了下来，段寄存器还是 16 位是因为够用了，所以没必要扩充。</p>
<p>​    虽说段机制保留了，但是段基值都设置为 0 ，就用段内偏移地址来访问内存空间就好了。这其实就意味着每个段的起始地址都是一样的，那就等于不分段了，这就叫<strong>平坦模式</strong>。Linux 就是这样实现的。(Linux操作系统便是如此)    </p>
<hr>
<h2 id="逻辑地址转化"><a href="#逻辑地址转化" class="headerlink" title="逻辑地址转化"></a>逻辑地址转化</h2><p>​        给出一个逻辑地址，根据下图可以分析出转换成线性地址的过程：</p>
<ol>
<li>首先根据TI是0还是1确定是要转换GDT中的段还是LDT中的段。gdtr寄存器中可以得到GDT的入口地址，在ldtr寄存器中得到LDT的入口地址。</li>
<li>根据段选择符的前13位，即index字段。index字段乘以8可以计算出对应的段描述符的地址，这个记结果与上一步中得到的表的基地址相加就可以得到Base；</li>
<li>将Base + offset就可以得到转换的线性地址；</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/anyeyueren/picgoimg/studyImg/%E5%9C%B0%E5%9D%80%E6%98%A0%E5%B0%84.png"></p>
<hr>
<h2 id="段描述符"><a href="#段描述符" class="headerlink" title="段描述符"></a>段描述符</h2><p>​    每一个段都拥有一个段描述符(<em>segment descriptor</em>)描述段的特征，当有很多个段描述符时就会组成一个数组，叫做“段描述符表”。段描述符表又可以分为“**全局段描述符表(GDT)<strong>”和“</strong>局部段描述符表(LDT)**”。</p>
<blockquote>
<p>TI:          TI字段是<strong>段指示器</strong>，&#x3D;0时表示用GDT，&#x3D;1时表示用LDT。</p>
<p>index:   索引号指定了放在GDT或者LDT中的相应的段描述符入口；</p>
<p>RPL:       请求者特权级；</p>
</blockquote>
<p>​    通常只定义一个GDT，但是每个进程除了存放在GDT中的段之外还需要创建附加的段，这时候就有自己的LDT。<em>GDT</em>在内存中的地址和大小存放在<em>CPU</em>的<em>gdtr</em>控制寄存器中，而<em>LDT</em>则在<em>ldtr</em>寄存器中。</p>
<hr>
<h2 id="分段缺陷"><a href="#分段缺陷" class="headerlink" title="分段缺陷"></a>分段缺陷</h2><p>​    分段机制存在两个问题：</p>
<ul>
<li><strong>内存碎片问题</strong></li>
</ul>
<p>分段的粒度实在太粗了，很容易产生内碎片问题。外部内存碎片，也就是产生了多个不连续的小物理内存，导致新的程序无法被装载。</p>
<blockquote>
<p>分段为什么会产生内存碎片的问题？</p>
<p>答：假设有 1G 的物理内存，用户执行了多个程序，其中：游戏占用了 512MB 内存，浏览器占用了 128MB 内存，音乐占用了 256 MB 内存。这个时候，如果我们关闭了浏览器，则空闲内存还有 1024 - 512 - 256 &#x3D; 256MB。如果这个 256MB 不是连续的，被分成了两段 128 MB 内存，这就会导致没有空间再打开一个 200MB 的程序。</p>
<p>新的程序无法加载上来，内存中有两个128M内存碎片，只能加载占用内存小于128M的程序。</p>
</blockquote>
<p>​    解决外部内存碎片问题的方式就是：内存交换。可以将之前的音乐程序占用的那 256MB 内存写到硬盘上，然后再从硬盘上读回来到内存里。不过再读回的时候，我们不能装载回原来的位置，而是紧紧跟着那已经被占用了的 512MB 内存后面。这样就能空缺出连续的 256MB 空间，于是新的 200MB 程序就可以装载进来。</p>
<p>​    在 Linux 系统里，也就是我们常看到的<strong>swap空间</strong>，这块空间是从硬盘划分出来的，用于内存与硬盘的空间交换。</p>
<ul>
<li><strong>内存交换效率过低</strong></li>
</ul>
<p>对于多进程的系统来说，用分段的方式，内存碎片是很容易产生的，产生了内存碎片，那不得不重新 Swap 内存区域，这个过程会产生性能瓶颈。</p>
<p>因为硬盘的访问速度要比内存慢太多了，每一次内存交换，我们都需要把一大段连续的内存数据写到硬盘上。所以，如果内存交换的时候，交换的是一个占内存空间很大的程序，这样整个机器都会显得卡顿。</p>
<hr>
<h1 id="分页机制"><a href="#分页机制" class="headerlink" title="分页机制"></a>分页机制</h1><p>为了解决内存分段的存在的弊端问题，就出现了分页机制。一个更加精细化的内存管理方式。简单地说就是把内存等分成一页一页，<strong>每页 4KB 大小，按页为单位来管理内存。</strong>这样一来就不需要将一段程序都加载进内存，只需要将用到的页加载到内存中！大大提升了内存的利用效率。由于一页就 4KB， 所以内存交换的性能问题得以缓解，毕竟只要换一定的页。</p>
<blockquote>
<p>分段可以把每一个进程分配不同的线性地址空间，而分页又可以将同一个线性地址空间映射到不同的物理地址空间。</p>
<p>Linux更倾向于使用分页，因为：</p>
<ol>
<li>所有进程可以使用相同的段寄存器数值，它们可以共享同一组线性地址；</li>
<li>Linux操作系统目标是拥有强大的移植性，兼容分段但是不依赖分段让linux兼容性更强；</li>
</ol>
</blockquote>
<h2 id="段与页比较"><a href="#段与页比较" class="headerlink" title="段与页比较"></a>段与页比较</h2><table>
<thead>
<tr>
<th>段</th>
<th>页</th>
</tr>
</thead>
<tbody><tr>
<td>段是信息的逻辑单位，根据用户的需要划分，段对用户是可见的；</td>
<td>页是信息的物理单位，为管理内存方便和划分的，对用户透明的；</td>
</tr>
<tr>
<td>段的大小不固定；</td>
<td>页的大小固定；</td>
</tr>
<tr>
<td>段便于存储保护和信息共享；</td>
<td>页的保护和共享受到限制；</td>
</tr>
<tr>
<td>分段的粒度更大；</td>
<td>分页的粒度更小；</td>
</tr>
<tr>
<td>分段：将程序分为代码段、数据段、堆栈段等；</td>
<td>分页：将段分成均匀的小块，通过页表映射物理内存；</td>
</tr>
</tbody></table>
<h2 id="线性地址转化"><a href="#线性地址转化" class="headerlink" title="线性地址转化"></a>线性地址转化</h2><p>​    <strong>分页单元</strong>(paging unit)负责将线性地址转化成物理地址。为了提高效率，线性地址被分成固定长度单位的组，称之为页。页的内部是一组连续的线性地址，可以被映射到物理地址当中。内核便可以指定一个页的物理地址和其存取权限。</p>
<p>​    此外分页单元还将所有的RAM分成固定长度的<strong>页框</strong>(page frame)，也可以叫做<strong>物理页</strong>。每一个页框包含了一页，页框和页不一样。页只是一块数据块，可以存放在页框或磁盘上。页框长度与页长度一致，是主存的一部分，也是一个存储区域。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//内核使用struct page结构体描述每一个物理页，也就叫做页框</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">page</span> &#123;</span></span><br><span class="line">	<span class="comment">/* First double word block */</span></span><br><span class="line">	<span class="type">unsigned</span> <span class="type">long</span> flags;		<span class="comment">/* 页标志*/</span></span><br><span class="line">    <span class="type">atomic_t</span> _mapcount;         <span class="comment">/* 页映射计数*/</span></span><br><span class="line">    <span class="type">atomic_t</span> mm_count;          <span class="comment">/* 页引用计数*/</span></span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">address_space</span> *<span class="title">mapping</span>;</span>	<span class="comment">/* 该页所在地址空间描述结构指针，用于内容为文件的页帧*/</span></span><br><span class="line">	<span class="comment">/* Second double word */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">		<span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">			<span class="type">pgoff_t</span> index;		<span class="comment">/*该页描述结构在地址空间radix和page_tree中的对象索引号即页号 */</span></span><br><span class="line">			<span class="type">void</span> *freelist;		<span class="comment">/* slub/slob first free object */</span></span><br><span class="line">			<span class="type">bool</span> pfmemalloc;	<span class="comment">/* If set by the page allocator,</span></span><br><span class="line"><span class="comment">						 * ALLOC_NO_WATERMARKS was set</span></span><br><span class="line"><span class="comment">						 * and the low watermark was not</span></span><br><span class="line"><span class="comment">						 * met implying that the system</span></span><br><span class="line"><span class="comment">						 * is under some pressure. The</span></span><br><span class="line"><span class="comment">						 * caller should try ensure</span></span><br><span class="line"><span class="comment">						 * this page is only used to</span></span><br><span class="line"><span class="comment">						 * free other pages.</span></span><br><span class="line"><span class="comment">						 */</span></span><br><span class="line">		&#125;;</span><br><span class="line">        </span><br><span class="line">     <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">lru</span>;</span> <span class="comment">/* 未使用struct slab结构指针链表头变量 */</span></span><br><span class="line">  ......</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>​    线性地址的页映射到物理页的数据结构称为**页表(page table)**。页表存放在主存中，并在启用分页单元之前由内核对页表适当初始化。（页表实际上存储在 CPU 的内存管理单元MMU中）</p>
<p>​    线性地址由三个部分组成：10位的**<u>页目录项</u><strong>(22 ~ 31)、10位的</strong><u>页表项</u><strong>(12 ~ 21)和12位</strong><u>页内偏移值</u>**(0 ~ 11)。一个页目录表拥有1024个页目录项，这些页目录项与页表一一对应。每个页表中有1024个页表项，每个页表项与一个物理页对应，所以32位线性地址可寻址空间为：1024 * 1024 * 4KB &#x3D; 4GB。</p>
<hr>
<p>线性地址空间中某个页的地址如何转换成到某个物理页中的物理地址。</p>
<ol>
<li>一个系统中可以有若干个页目录表，但是在某一时刻只有一个生效，CPU中<strong>CR3寄存器</strong>记录当前使用的页目录表；(现在的windows和Linux都是每个进程一个页目录表)</li>
<li>接着根据线性地址中的页目录项找对应的页表，页表中的页表项对应一个个的物理页；</li>
<li>根据线性地址中的页表项定位到所需要的物理页的基地址；</li>
<li>最后根据线性地址中的页内偏移量找到该物理页中所需要的那个物理地址；</li>
</ol>
<blockquote>
<p>Linux系统中，用户空间每个进程都有自己单独的页目录表，内核空间共用只有一个页目录表。不同进程访问同一个线性地址是不会访问到同一个物理页的，因为页目录表不一样，这就做到了进程与进程间的地址隔离。</p>
</blockquote>
<hr>
<h1 id="Linux的段式管理"><a href="#Linux的段式管理" class="headerlink" title="Linux的段式管理"></a>Linux的段式管理</h1><p>​    上面提到过Linux更喜欢用分页方式，但是为了兼容还是保留了段式管理的。Linux只有在80x86结构下才需要使用分段。下面是Linux主要的四个段的段描述符字段的值：</p>
<table>
<thead>
<tr>
<th>段</th>
<th>Base</th>
<th>Limit</th>
<th>Type</th>
<th>DPL</th>
</tr>
</thead>
<tbody><tr>
<td>用户代码段</td>
<td>0x00000000</td>
<td>0xffffff</td>
<td>10</td>
<td>3</td>
</tr>
<tr>
<td>用户数据段</td>
<td>0x00000000</td>
<td>0xffffff</td>
<td>2</td>
<td>3</td>
</tr>
<tr>
<td>内核代码段</td>
<td>0x00000000</td>
<td>0xffffff</td>
<td>10</td>
<td>0</td>
</tr>
<tr>
<td>内核数据段</td>
<td>0x00000000</td>
<td>0xffffff</td>
<td>2</td>
<td>0</td>
</tr>
</tbody></table>
<p>​    从源码中查看实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span>          GDT_ENTRY_DEFAULT_USER_CS       </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>          __USER_CS       (GDT_ENTRY_DEFAULT_USER_CS * 8 + 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>          GDT_ENTRY_DEFAULT_USER_DS       </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>          __USER_DS (GDT_ENTRY_DEFAULT_USER_DS * 8 + 3)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>          GDT_ENTRY_KERNEL_BASE       </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>          GDT_ENTRY_KERNEL_CS   (GDT_ENTRY_KERNEL_BASE+ 0)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>          __KERNEL_CS  (GDT_ENTRY_KERNEL_CS * 8)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>          GDT_ENTRY_KERNEL_DS   (GDT_ENTRY_KERNEL_BASE+ 1)</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span>          __KERNEL_DS  (GDT_ENTRY_KERNEL_DS * 8)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*将宏转化为数值*/</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USER_CS                115     [00000000 1110  0  11]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __USER_DS                123     [00000000 1111  0  11]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERNEL_CS               96     [00000000 1100  0  00]</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> __KERNEL_DS              104     [00000000 1101  0  00]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*索引号和T1字段值可以计算出来，T1均为0，则表示都使用了GDT*/</span></span><br><span class="line">__USER_CS              index= <span class="number">14</span>             T1=<span class="number">0</span></span><br><span class="line">__USER_DS              index= <span class="number">15</span>             T1=<span class="number">0</span></span><br><span class="line">__KERNEL_C             index= <span class="number">12</span>             T1=<span class="number">0</span></span><br><span class="line">__KERNEL_DS            index= <span class="number">13</span>             T1=<span class="number">0</span></span><br><span class="line"><span class="comment">/*进一步看再来看初始化GDT的内容中相应的12-15项(arch/i386/head.S)*/</span></span><br><span class="line">.quad <span class="number">0x00cf9a000000ffff</span>         <span class="comment">/* 0x60 kernel 4GB code   at 0x00000000 */</span></span><br><span class="line">.quad <span class="number">0x00cf92000000ffff</span>         <span class="comment">/* 0x68 kernel 4GB data    at 0x00000000 */</span></span><br><span class="line">.quad <span class="number">0x00cffa000000ffff</span>          <span class="comment">/* 0x73 user 4GB  code   at 0x00000000 */</span></span><br><span class="line">.quad <span class="number">0x00cff2000000ffff</span>          <span class="comment">/* 0x7b user 4GB  data    at 0x00000000 */</span></span><br></pre></td></tr></table></figure>

<p>​    可以发现其16-31位全为<em>0</em>，即四个段的基地址全为<em>0</em>。 这样，给定一个段内偏移地址，按照前面转换公式，0 +段内偏移，转换为线性地址。可以得出结论：</p>
<blockquote>
<p>Linux下逻辑地址与线性地址是一致的，逻辑地址的偏移量字段数值对应的就是相应的线性地址的值一致。</p>
</blockquote>
<p>​    进一步来了解虚拟寻址：</p>
<blockquote>
<p><strong>Tips:如何理解虚拟寻址？</strong></p>
<p>打个比方，你有一本笔记本，每页都有页码，现在是空的，你可以在上边记东西。你要上语文数学英语三门课，三门课的笔记要记在基本上。显然，这三门课是混着上的，所以如果你从前往后记笔记，这三门课的内容是混起来的。</p>
<p>你需要不时翻找每门课的笔记，但是因为内容都是混在一起的，查找很困难，所以你想到了一个办法：记笔记的时候，记语文的页只记语文，不把其他课的内容混在一起。并且用单独的三页记录每门课的笔记的页码。你管这种记录方式叫做页表。笔记每多记一页，就在相应的学科的页表上记上笔记本页数。</p>
<p>于是你需要找语文第10页的时候，只要看语文的页表，发现语文第10页放在笔记本的第20页上，那么你只要翻到笔记本第20页就能看到你想要的内容了。</p>
<p>在这个例子中：</p>
<p>​                         笔记本                           –      物理内存</p>
<p>​                         笔记本页码                    –     物理地址</p>
<p>​                         笔记页                            –     页框 (Page frame)</p>
<p>​                         页表                                –     页表 (Page table)</p>
<p>​                         页表内容                        –     页表项 (Page table entry)</p>
<p>​                         语文页码                        –     虚拟地址</p>
<p>​                         语文页表形成的空间     –     虚拟内存空间</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="mailto:undefined">Barret</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://example.com/2021/05/02/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%B8%80)/">http://example.com/2021/05/02/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%B8%80)/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">Barret Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"></div><div class="post_share"><div class="social-share" data-image="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2021/05/03/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E5%9B%9B)/"><img class="prev-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">Linux环境内存管理(四)</div></div></a></div><div class="next-post pull-right"><a href="/2021/05/02/Linux/Linux%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%86%85%E6%A0%B8/Linux%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/Linux%E7%8E%AF%E5%A2%83%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86(%E4%BA%8C)/"><img class="next-cover" src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">Linux环境内存管理(二)</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Finews.gtimg.com%2Fnewsapp_bt%2F0%2F14206928472%2F1000.jpg&amp;refer=http%3A%2F%2Finews.gtimg.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650157497&amp;t=70dfbdc4919a4e744f090628aaf5059d" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">Barret</div><div class="author-info__description">Welcome Visit</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">49</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">0</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">0</div></a></div></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/xxxxxx"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/anyeyueren" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:2412704562@qq.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">This is my Blog</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E7%AE%80%E4%BB%8B"><span class="toc-number">1.</span> <span class="toc-text">操作系统简介</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#linux%E5%86%85%E5%AD%98%E6%A6%82%E8%BF%B0"><span class="toc-number">1.1.</span> <span class="toc-text">linux内存概述</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86"><span class="toc-number">2.</span> <span class="toc-text">内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%AF%BB%E5%9D%80"><span class="toc-number">3.</span> <span class="toc-text">寻址</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%A9%E7%90%86%E5%AF%BB%E5%9D%80"><span class="toc-number">3.1.</span> <span class="toc-text">物理寻址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%99%9A%E6%8B%9F%E5%AF%BB%E5%9D%80"><span class="toc-number">3.2.</span> <span class="toc-text">虚拟寻址</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%86%85%E5%AD%98%E5%9C%B0%E5%9D%80"><span class="toc-number">3.3.</span> <span class="toc-text">内存地址</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">4.</span> <span class="toc-text">分段机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BF%9D%E6%8A%A4%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%AE%9E%E6%A8%A1%E5%BC%8F"><span class="toc-number">4.1.</span> <span class="toc-text">保护模式和实模式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%BB%E8%BE%91%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8C%96"><span class="toc-number">4.2.</span> <span class="toc-text">逻辑地址转化</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E6%8F%8F%E8%BF%B0%E7%AC%A6"><span class="toc-number">4.3.</span> <span class="toc-text">段描述符</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%AE%B5%E7%BC%BA%E9%99%B7"><span class="toc-number">4.4.</span> <span class="toc-text">分段缺陷</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%88%86%E9%A1%B5%E6%9C%BA%E5%88%B6"><span class="toc-number">5.</span> <span class="toc-text">分页机制</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%AE%B5%E4%B8%8E%E9%A1%B5%E6%AF%94%E8%BE%83"><span class="toc-number">5.1.</span> <span class="toc-text">段与页比较</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BA%BF%E6%80%A7%E5%9C%B0%E5%9D%80%E8%BD%AC%E5%8C%96"><span class="toc-number">5.2.</span> <span class="toc-text">线性地址转化</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Linux%E7%9A%84%E6%AE%B5%E5%BC%8F%E7%AE%A1%E7%90%86"><span class="toc-number">6.</span> <span class="toc-text">Linux的段式管理</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E4%B8%83)/" title="进程同步和信号量"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="进程同步和信号量"/></a><div class="content"><a class="title" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E4%B8%83)/" title="进程同步和信号量">进程同步和信号量</a><time datetime="2021-11-24T22:04:16.000Z" title="发表于 2021-11-25 06:04:16">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%85%AB)/" title="信号量临界区保护"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="信号量临界区保护"/></a><div class="content"><a class="title" href="/2021/11/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%85%AB)/" title="信号量临界区保护">信号量临界区保护</a><time datetime="2021-11-24T22:04:16.000Z" title="发表于 2021-11-25 06:04:16">2021-11-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/29/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%85%AD)/" title="CPU调度策略"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="CPU调度策略"/></a><div class="content"><a class="title" href="/2021/10/29/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E5%85%AD)/" title="CPU调度策略">CPU调度策略</a><time datetime="2021-10-28T22:04:16.000Z" title="发表于 2021-10-29 06:04:16">2021-10-29</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E4%BA%94)/" title="内核级线程"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="内核级线程"/></a><div class="content"><a class="title" href="/2021/10/25/Linux/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E5%8E%9F%E7%90%86%E5%89%96%E6%9E%90/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F(%E4%BA%94)/" title="内核级线程">内核级线程</a><time datetime="2021-10-24T22:04:16.000Z" title="发表于 2021-10-25 06:04:16">2021-10-25</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/2021/10/17/C++%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="智能指针"><img src="https://gimg2.baidu.com/image_search/src=http%3A%2F%2Fup.enterdesk.com%2Fedpic_source%2F06%2F78%2F41%2F067841122a06a611ddcf6a7f1dade3dc.jpg&amp;refer=http%3A%2F%2Fup.enterdesk.com&amp;app=2002&amp;size=f9999,10000&amp;q=a80&amp;n=0&amp;g=0n&amp;fmt=auto?sec=1650272949&amp;t=18f99d2e597ef4e5080a0e7cdc68b6e1" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="智能指针"/></a><div class="content"><a class="title" href="/2021/10/17/C++%E6%96%B0%E5%A2%9E%E7%89%B9%E6%80%A7/%E6%99%BA%E8%83%BD%E6%8C%87%E9%92%88/" title="智能指针">智能指针</a><time datetime="2021-10-16T22:04:16.000Z" title="发表于 2021-10-17 06:04:16">2021-10-17</time></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"><div class="copyright">&copy;2022 By Barret</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>